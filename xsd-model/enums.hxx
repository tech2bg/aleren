// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MODEL_ENUMS_HXX
#define CXX___SCHEMA_XSD_MODEL_ENUMS_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdConvexityMethod;
class XsdDiscountType;
class XsdPriceVolatilityType;
class XsdHazardType;
class XsdOutputType;
class XsdProcessType;
class XsdRateVolatilityType;
class XsdScenarioType;
class XsdSpreadType;
class XsdTermStructureType;
class XsdVolatilityBoundaryType;
class XsdVolatilityCategory;
class XsdVolatilityType;
class XsdYieldType;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "../xsd-asset/enums.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "../xsd-asset/enums.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdConvexityMethod: public ::xml_schema::string
{
  public:
  enum value
  {
    HO_LEE,
    HULL_WHITE,
    KIRIKOS_NOVAK,
    NONE
  };

  XsdConvexityMethod ();

  XsdConvexityMethod (value v);

  XsdConvexityMethod (const char* v);

  XsdConvexityMethod (const ::std::string& v);

  XsdConvexityMethod (const ::xml_schema::string& v);

  XsdConvexityMethod (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdConvexityMethod (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdConvexityMethod (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdConvexityMethod (const XsdConvexityMethod& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdConvexityMethod*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdConvexityMethod&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdConvexityMethod_convert ();
  }

  protected:
  value
  _xsd_XsdConvexityMethod_convert () const;

  public:
  static const char* const _xsd_XsdConvexityMethod_literals_[4];
  static const value _xsd_XsdConvexityMethod_indexes_[4];
};

class XsdDiscountType: public ::xml_schema::string
{
  public:
  enum value
  {
    DISCOUNT,
    DV01,
    FORWARD,
    SPOT,
    SWAP
  };

  XsdDiscountType ();

  XsdDiscountType (value v);

  XsdDiscountType (const char* v);

  XsdDiscountType (const ::std::string& v);

  XsdDiscountType (const ::xml_schema::string& v);

  XsdDiscountType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdDiscountType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdDiscountType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdDiscountType (const XsdDiscountType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdDiscountType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdDiscountType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdDiscountType_convert ();
  }

  protected:
  value
  _xsd_XsdDiscountType_convert () const;

  public:
  static const char* const _xsd_XsdDiscountType_literals_[5];
  static const value _xsd_XsdDiscountType_indexes_[5];
};

class XsdPriceVolatilityType: public ::xml_schema::string
{
  public:
  enum value
  {
    BLACK,
    LOCAL
  };

  XsdPriceVolatilityType ();

  XsdPriceVolatilityType (value v);

  XsdPriceVolatilityType (const char* v);

  XsdPriceVolatilityType (const ::std::string& v);

  XsdPriceVolatilityType (const ::xml_schema::string& v);

  XsdPriceVolatilityType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdPriceVolatilityType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdPriceVolatilityType (const ::std::string& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdPriceVolatilityType (const XsdPriceVolatilityType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual XsdPriceVolatilityType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdPriceVolatilityType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdPriceVolatilityType_convert ();
  }

  protected:
  value
  _xsd_XsdPriceVolatilityType_convert () const;

  public:
  static const char* const _xsd_XsdPriceVolatilityType_literals_[2];
  static const value _xsd_XsdPriceVolatilityType_indexes_[2];
};

class XsdHazardType: public ::xml_schema::string
{
  public:
  enum value
  {
    CREDIT_SPREAD,
    DEFAULT_PROBABILITY,
    DEFAULT_DENSITY,
    FORWARD_HAZARD_RATE,
    SURVIVAL_PROBABILITY,
    SPOT_HAZARD_RATE
  };

  XsdHazardType ();

  XsdHazardType (value v);

  XsdHazardType (const char* v);

  XsdHazardType (const ::std::string& v);

  XsdHazardType (const ::xml_schema::string& v);

  XsdHazardType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdHazardType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdHazardType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdHazardType (const XsdHazardType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdHazardType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdHazardType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdHazardType_convert ();
  }

  protected:
  value
  _xsd_XsdHazardType_convert () const;

  public:
  static const char* const _xsd_XsdHazardType_literals_[6];
  static const value _xsd_XsdHazardType_indexes_[6];
};

class XsdOutputType: public ::xml_schema::string
{
  public:
  enum value
  {
    EXPECTED,
    NONE,
    PATHWISE,
    SUMMARY
  };

  XsdOutputType ();

  XsdOutputType (value v);

  XsdOutputType (const char* v);

  XsdOutputType (const ::std::string& v);

  XsdOutputType (const ::xml_schema::string& v);

  XsdOutputType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdOutputType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdOutputType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdOutputType (const XsdOutputType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdOutputType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdOutputType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdOutputType_convert ();
  }

  protected:
  value
  _xsd_XsdOutputType_convert () const;

  public:
  static const char* const _xsd_XsdOutputType_literals_[4];
  static const value _xsd_XsdOutputType_indexes_[4];
};

class XsdProcessType: public ::xml_schema::string
{
  public:
  enum value
  {
    HYBRID,
    PRICE,
    RATE,
    SPREAD,
    WITHDRAW
  };

  XsdProcessType ();

  XsdProcessType (value v);

  XsdProcessType (const char* v);

  XsdProcessType (const ::std::string& v);

  XsdProcessType (const ::xml_schema::string& v);

  XsdProcessType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdProcessType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdProcessType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdProcessType (const XsdProcessType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdProcessType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdProcessType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdProcessType_convert ();
  }

  protected:
  value
  _xsd_XsdProcessType_convert () const;

  public:
  static const char* const _xsd_XsdProcessType_literals_[5];
  static const value _xsd_XsdProcessType_indexes_[5];
};

class XsdRateVolatilityType: public ::xml_schema::string
{
  public:
  enum value
  {
    CALLABLE,
    CAPLET,
    CAP_FLOOR,
    SWAPTION
  };

  XsdRateVolatilityType ();

  XsdRateVolatilityType (value v);

  XsdRateVolatilityType (const char* v);

  XsdRateVolatilityType (const ::std::string& v);

  XsdRateVolatilityType (const ::xml_schema::string& v);

  XsdRateVolatilityType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdRateVolatilityType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdRateVolatilityType (const ::std::string& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdRateVolatilityType (const XsdRateVolatilityType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual XsdRateVolatilityType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdRateVolatilityType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdRateVolatilityType_convert ();
  }

  protected:
  value
  _xsd_XsdRateVolatilityType_convert () const;

  public:
  static const char* const _xsd_XsdRateVolatilityType_literals_[4];
  static const value _xsd_XsdRateVolatilityType_indexes_[4];
};

class XsdScenarioType: public ::xml_schema::string
{
  public:
  enum value
  {
    FIXED,
    FORWARD,
    RANDOM,
    POOL
  };

  XsdScenarioType ();

  XsdScenarioType (value v);

  XsdScenarioType (const char* v);

  XsdScenarioType (const ::std::string& v);

  XsdScenarioType (const ::xml_schema::string& v);

  XsdScenarioType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdScenarioType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdScenarioType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdScenarioType (const XsdScenarioType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdScenarioType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdScenarioType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdScenarioType_convert ();
  }

  protected:
  value
  _xsd_XsdScenarioType_convert () const;

  public:
  static const char* const _xsd_XsdScenarioType_literals_[4];
  static const value _xsd_XsdScenarioType_indexes_[4];
};

class XsdSpreadType: public ::xml_schema::string
{
  public:
  enum value
  {
    OPTION_ADJUSTED,
    ZERO_VOLATILITY
  };

  XsdSpreadType ();

  XsdSpreadType (value v);

  XsdSpreadType (const char* v);

  XsdSpreadType (const ::std::string& v);

  XsdSpreadType (const ::xml_schema::string& v);

  XsdSpreadType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSpreadType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSpreadType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSpreadType (const XsdSpreadType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdSpreadType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdSpreadType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdSpreadType_convert ();
  }

  protected:
  value
  _xsd_XsdSpreadType_convert () const;

  public:
  static const char* const _xsd_XsdSpreadType_literals_[2];
  static const value _xsd_XsdSpreadType_indexes_[2];
};

class XsdTermStructureType: public ::xml_schema::string
{
  public:
  enum value
  {
    COMMODITY,
    CORRELATION,
    CURRENCY,
    DISCOUNT,
    HAZARD,
    INFLATION,
    EXPECTED_LOSS,
    VOLATILITY
  };

  XsdTermStructureType ();

  XsdTermStructureType (value v);

  XsdTermStructureType (const char* v);

  XsdTermStructureType (const ::std::string& v);

  XsdTermStructureType (const ::xml_schema::string& v);

  XsdTermStructureType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdTermStructureType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdTermStructureType (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdTermStructureType (const XsdTermStructureType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdTermStructureType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdTermStructureType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdTermStructureType_convert ();
  }

  protected:
  value
  _xsd_XsdTermStructureType_convert () const;

  public:
  static const char* const _xsd_XsdTermStructureType_literals_[8];
  static const value _xsd_XsdTermStructureType_indexes_[8];
};

class XsdVolatilityBoundaryType: public ::xml_schema::string
{
  public:
  enum value
  {
    CHISQ_VARIANCE,
    QUADRATIC_EXP,
    QUADRATIC_EXP_MG,
    REFLECT,
    TRUNCATE_FULL,
    TRUNCATE_PARTIAL
  };

  XsdVolatilityBoundaryType ();

  XsdVolatilityBoundaryType (value v);

  XsdVolatilityBoundaryType (const char* v);

  XsdVolatilityBoundaryType (const ::std::string& v);

  XsdVolatilityBoundaryType (const ::xml_schema::string& v);

  XsdVolatilityBoundaryType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdVolatilityBoundaryType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdVolatilityBoundaryType (const ::std::string& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdVolatilityBoundaryType (const XsdVolatilityBoundaryType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual XsdVolatilityBoundaryType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdVolatilityBoundaryType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdVolatilityBoundaryType_convert ();
  }

  protected:
  value
  _xsd_XsdVolatilityBoundaryType_convert () const;

  public:
  static const char* const _xsd_XsdVolatilityBoundaryType_literals_[6];
  static const value _xsd_XsdVolatilityBoundaryType_indexes_[6];
};

class XsdVolatilityCategory: public ::xml_schema::string
{
  public:
  enum value
  {
    INFLATION,
    PRICE,
    RATE
  };

  XsdVolatilityCategory ();

  XsdVolatilityCategory (value v);

  XsdVolatilityCategory (const char* v);

  XsdVolatilityCategory (const ::std::string& v);

  XsdVolatilityCategory (const ::xml_schema::string& v);

  XsdVolatilityCategory (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdVolatilityCategory (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdVolatilityCategory (const ::std::string& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdVolatilityCategory (const XsdVolatilityCategory& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual XsdVolatilityCategory*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdVolatilityCategory&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdVolatilityCategory_convert ();
  }

  protected:
  value
  _xsd_XsdVolatilityCategory_convert () const;

  public:
  static const char* const _xsd_XsdVolatilityCategory_literals_[3];
  static const value _xsd_XsdVolatilityCategory_indexes_[3];
};

class XsdVolatilityType: public ::xml_schema::string
{
  public:
  enum value
  {
    BLACK,
    LOCAL,
    CALLABLE,
    CAPLET,
    CAP_FLOOR,
    SWAPTION,
    YEAR_ON_YEAR,
    ZERO_COUPON
  };

  XsdVolatilityType ();

  XsdVolatilityType (value v);

  XsdVolatilityType (const char* v);

  XsdVolatilityType (const ::std::string& v);

  XsdVolatilityType (const ::xml_schema::string& v);

  XsdVolatilityType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdVolatilityType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdVolatilityType (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdVolatilityType (const XsdVolatilityType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdVolatilityType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdVolatilityType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdVolatilityType_convert ();
  }

  protected:
  value
  _xsd_XsdVolatilityType_convert () const;

  public:
  static const char* const _xsd_XsdVolatilityType_literals_[8];
  static const value _xsd_XsdVolatilityType_indexes_[8];
};

class XsdYieldType: public ::xml_schema::string
{
  public:
  enum value
  {
    MATURITY,
    CALL,
    WORST,
    CASHFLOW
  };

  XsdYieldType ();

  XsdYieldType (value v);

  XsdYieldType (const char* v);

  XsdYieldType (const ::std::string& v);

  XsdYieldType (const ::xml_schema::string& v);

  XsdYieldType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdYieldType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdYieldType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdYieldType (const XsdYieldType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual XsdYieldType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdYieldType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdYieldType_convert ();
  }

  protected:
  value
  _xsd_XsdYieldType_convert () const;

  public:
  static const char* const _xsd_XsdYieldType_literals_[4];
  static const value _xsd_XsdYieldType_indexes_[4];
};

#ifndef XSD_DONT_INCLUDE_INLINE

#include "../xsd-asset/enums.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, XsdConvexityMethod::value);

::std::ostream&
operator<< (::std::ostream&, const XsdConvexityMethod&);

::std::ostream&
operator<< (::std::ostream&, XsdDiscountType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdDiscountType&);

::std::ostream&
operator<< (::std::ostream&, XsdPriceVolatilityType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdPriceVolatilityType&);

::std::ostream&
operator<< (::std::ostream&, XsdHazardType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdHazardType&);

::std::ostream&
operator<< (::std::ostream&, XsdOutputType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdOutputType&);

::std::ostream&
operator<< (::std::ostream&, XsdProcessType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdProcessType&);

::std::ostream&
operator<< (::std::ostream&, XsdRateVolatilityType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdRateVolatilityType&);

::std::ostream&
operator<< (::std::ostream&, XsdScenarioType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdScenarioType&);

::std::ostream&
operator<< (::std::ostream&, XsdSpreadType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdSpreadType&);

::std::ostream&
operator<< (::std::ostream&, XsdTermStructureType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdTermStructureType&);

::std::ostream&
operator<< (::std::ostream&, XsdVolatilityBoundaryType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdVolatilityBoundaryType&);

::std::ostream&
operator<< (::std::ostream&, XsdVolatilityCategory::value);

::std::ostream&
operator<< (::std::ostream&, const XsdVolatilityCategory&);

::std::ostream&
operator<< (::std::ostream&, XsdVolatilityType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdVolatilityType&);

::std::ostream&
operator<< (::std::ostream&, XsdYieldType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdYieldType&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdConvexityMethod&);

void
operator<< (xercesc::DOMAttr&, const XsdConvexityMethod&);

void
operator<< (::xml_schema::list_stream&,
            const XsdConvexityMethod&);

void
operator<< (xercesc::DOMElement&, const XsdDiscountType&);

void
operator<< (xercesc::DOMAttr&, const XsdDiscountType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdDiscountType&);

void
operator<< (xercesc::DOMElement&, const XsdPriceVolatilityType&);

void
operator<< (xercesc::DOMAttr&, const XsdPriceVolatilityType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdPriceVolatilityType&);

void
operator<< (xercesc::DOMElement&, const XsdHazardType&);

void
operator<< (xercesc::DOMAttr&, const XsdHazardType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdHazardType&);

void
operator<< (xercesc::DOMElement&, const XsdOutputType&);

void
operator<< (xercesc::DOMAttr&, const XsdOutputType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdOutputType&);

void
operator<< (xercesc::DOMElement&, const XsdProcessType&);

void
operator<< (xercesc::DOMAttr&, const XsdProcessType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdProcessType&);

void
operator<< (xercesc::DOMElement&, const XsdRateVolatilityType&);

void
operator<< (xercesc::DOMAttr&, const XsdRateVolatilityType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdRateVolatilityType&);

void
operator<< (xercesc::DOMElement&, const XsdScenarioType&);

void
operator<< (xercesc::DOMAttr&, const XsdScenarioType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdScenarioType&);

void
operator<< (xercesc::DOMElement&, const XsdSpreadType&);

void
operator<< (xercesc::DOMAttr&, const XsdSpreadType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSpreadType&);

void
operator<< (xercesc::DOMElement&, const XsdTermStructureType&);

void
operator<< (xercesc::DOMAttr&, const XsdTermStructureType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdTermStructureType&);

void
operator<< (xercesc::DOMElement&, const XsdVolatilityBoundaryType&);

void
operator<< (xercesc::DOMAttr&, const XsdVolatilityBoundaryType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdVolatilityBoundaryType&);

void
operator<< (xercesc::DOMElement&, const XsdVolatilityCategory&);

void
operator<< (xercesc::DOMAttr&, const XsdVolatilityCategory&);

void
operator<< (::xml_schema::list_stream&,
            const XsdVolatilityCategory&);

void
operator<< (xercesc::DOMElement&, const XsdVolatilityType&);

void
operator<< (xercesc::DOMAttr&, const XsdVolatilityType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdVolatilityType&);

void
operator<< (xercesc::DOMElement&, const XsdYieldType&);

void
operator<< (xercesc::DOMAttr&, const XsdYieldType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdYieldType&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "enums.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MODEL_ENUMS_HXX
