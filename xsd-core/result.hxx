// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_CORE_RESULT_HXX
#define CXX___SCHEMA_XSD_CORE_RESULT_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdResult;
class XsdBooleanResult;
class XsdDateResult;
class XsdDateTimeResult;
class XsdDoubleResult;
class XsdErrorResult;
class XsdIntegerResult;
class XsdStringResult;
class XsdTenorResult;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "types.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "types.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdResult: public ::xml_schema::type
{
  public:
  // comment
  // 
  typedef ::xml_schema::string comment_type;
  typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
  typedef xsd::cxx::tree::sequence< comment_type >::iterator comment_iterator;
  typedef xsd::cxx::tree::sequence< comment_type >::const_iterator comment_const_iterator;
  typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

  const comment_sequence&
  comment () const;

  comment_sequence&
  comment ();

  void
  comment (const comment_sequence& s);

  // calculationID
  // 
  typedef ::xml_schema::idref calculationID_type;
  typedef ::xsd::cxx::tree::traits< calculationID_type, char > calculationID_traits;

  const calculationID_type&
  calculationID () const;

  calculationID_type&
  calculationID ();

  void
  calculationID (const calculationID_type& x);

  void
  calculationID (::std::auto_ptr< calculationID_type > p);

  // elapsedTime
  // 
  typedef ::xml_schema::duration elapsedTime_type;
  typedef ::xsd::cxx::tree::optional< elapsedTime_type > elapsedTime_optional;
  typedef ::xsd::cxx::tree::traits< elapsedTime_type, char > elapsedTime_traits;

  const elapsedTime_optional&
  elapsedTime () const;

  elapsedTime_optional&
  elapsedTime ();

  void
  elapsedTime (const elapsedTime_type& x);

  void
  elapsedTime (const elapsedTime_optional& x);

  void
  elapsedTime (::std::auto_ptr< elapsedTime_type > p);

  // Constructors.
  //
  XsdResult ();

  XsdResult (const calculationID_type&);

  XsdResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdResult (const xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdResult (const XsdResult& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual XsdResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  comment_sequence comment_;
  ::xsd::cxx::tree::one< calculationID_type > calculationID_;
  elapsedTime_optional elapsedTime_;
};

bool
operator== (const XsdResult&, const XsdResult&);

bool
operator!= (const XsdResult&, const XsdResult&);


class XsdBooleanResult: public ::XsdResult
{
  public:
  // Constructors.
  //
  XsdBooleanResult ();

  XsdBooleanResult (const ::XsdResult&);

  XsdBooleanResult (const calculationID_type&);

  XsdBooleanResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdBooleanResult (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdBooleanResult (const XsdBooleanResult& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdBooleanResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdBooleanResult ();
};

class XsdDateResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::date value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  XsdDateResult ();

  XsdDateResult (const ::XsdResult&,
                 const value_type&);

  XsdDateResult (const calculationID_type&,
                 const value_type&);

  XsdDateResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdDateResult (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdDateResult (const XsdDateResult& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdDateResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDateResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdDateResult&, const XsdDateResult&);

bool
operator!= (const XsdDateResult&, const XsdDateResult&);


class XsdDateTimeResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::date_time value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  XsdDateTimeResult ();

  XsdDateTimeResult (const ::XsdResult&,
                     const value_type&);

  XsdDateTimeResult (const calculationID_type&,
                     const value_type&);

  XsdDateTimeResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdDateTimeResult (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdDateTimeResult (const XsdDateTimeResult& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdDateTimeResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDateTimeResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdDateTimeResult&, const XsdDateTimeResult&);

bool
operator!= (const XsdDateTimeResult&, const XsdDateTimeResult&);


class XsdDoubleResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  XsdDoubleResult ();

  XsdDoubleResult (const ::XsdResult&,
                   const value_type&);

  XsdDoubleResult (const calculationID_type&,
                   const value_type&);

  XsdDoubleResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdDoubleResult (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdDoubleResult (const XsdDoubleResult& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdDoubleResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDoubleResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdDoubleResult&, const XsdDoubleResult&);

bool
operator!= (const XsdDoubleResult&, const XsdDoubleResult&);


class XsdErrorResult: public ::XsdResult
{
  public:
  // error
  // 
  typedef ::XsdException error_type;
  typedef ::xsd::cxx::tree::traits< error_type, char > error_traits;

  const error_type&
  error () const;

  error_type&
  error ();

  void
  error (const error_type& x);

  void
  error (::std::auto_ptr< error_type > p);

  // Constructors.
  //
  XsdErrorResult ();

  XsdErrorResult (const ::XsdResult&,
                  const error_type&);

  XsdErrorResult (const ::XsdResult&,
                  ::std::auto_ptr< error_type >&);

  XsdErrorResult (const calculationID_type&,
                  const error_type&);

  XsdErrorResult (const calculationID_type&,
                  ::std::auto_ptr< error_type >&);

  XsdErrorResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdErrorResult (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdErrorResult (const XsdErrorResult& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdErrorResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdErrorResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< error_type > error_;
};

bool
operator== (const XsdErrorResult&, const XsdErrorResult&);

bool
operator!= (const XsdErrorResult&, const XsdErrorResult&);


class XsdIntegerResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // Constructors.
  //
  XsdIntegerResult ();

  XsdIntegerResult (const ::XsdResult&,
                    const value_type&);

  XsdIntegerResult (const calculationID_type&,
                    const value_type&);

  XsdIntegerResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdIntegerResult (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdIntegerResult (const XsdIntegerResult& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdIntegerResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdIntegerResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdIntegerResult&, const XsdIntegerResult&);

bool
operator!= (const XsdIntegerResult&, const XsdIntegerResult&);


class XsdStringResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  XsdStringResult ();

  XsdStringResult (const ::XsdResult&,
                   const value_type&);

  XsdStringResult (const calculationID_type&,
                   const value_type&);

  XsdStringResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdStringResult (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdStringResult (const XsdStringResult& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdStringResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdStringResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdStringResult&, const XsdStringResult&);

bool
operator!= (const XsdStringResult&, const XsdStringResult&);


class XsdTenorResult: public ::XsdResult
{
  public:
  // value
  // 
  typedef ::xml_schema::duration value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  XsdTenorResult ();

  XsdTenorResult (const ::XsdResult&,
                  const value_type&);

  XsdTenorResult (const calculationID_type&,
                  const value_type&);

  XsdTenorResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdTenorResult (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdTenorResult (const XsdTenorResult& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdTenorResult*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdTenorResult ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< value_type > value_;
};

bool
operator== (const XsdTenorResult&, const XsdTenorResult&);

bool
operator!= (const XsdTenorResult&, const XsdTenorResult&);


#ifndef XSD_DONT_INCLUDE_INLINE

#include "types.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const XsdResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdBooleanResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdDateResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdDateTimeResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdDoubleResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdErrorResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdIntegerResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdStringResult&);

::std::ostream&
operator<< (::std::ostream&, const XsdTenorResult&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdResult&);

void
operator<< (xercesc::DOMElement&, const XsdBooleanResult&);

void
operator<< (xercesc::DOMElement&, const XsdDateResult&);

void
operator<< (xercesc::DOMElement&, const XsdDateTimeResult&);

void
operator<< (xercesc::DOMElement&, const XsdDoubleResult&);

void
operator<< (xercesc::DOMElement&, const XsdErrorResult&);

void
operator<< (xercesc::DOMElement&, const XsdIntegerResult&);

void
operator<< (xercesc::DOMElement&, const XsdStringResult&);

void
operator<< (xercesc::DOMElement&, const XsdTenorResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdBooleanResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDateResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDateTimeResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDoubleResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdErrorResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdIntegerResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdStringResult&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdTenorResult&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "result.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_CORE_RESULT_HXX
