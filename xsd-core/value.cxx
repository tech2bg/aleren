// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "precompiled.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "value.hxx"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

// XsdBoolean
//

XsdBoolean::
XsdBoolean ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdBoolean::
XsdBoolean (const ::xml_schema::boolean& _xsd_boolean_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (_xsd_boolean_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdBoolean::
XsdBoolean (const XsdBoolean& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdBoolean::
XsdBoolean (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdBoolean::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdBoolean* XsdBoolean::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdBoolean (*this, f, c);
}

XsdBoolean::
~XsdBoolean ()
{
}

bool
operator== (const XsdBoolean& x, const XsdBoolean& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdBoolean& x, const XsdBoolean& y)
{
  return !(x == y);
}

// XsdComplex
//

XsdComplex::
XsdComplex ()
: ::xml_schema::type (),
  real_ (::xml_schema::flags (), this),
  imaginary_ (::xml_schema::flags (), this),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdComplex::
XsdComplex (const XsdComplex& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  real_ (x.real_, f, this),
  imaginary_ (x.imaginary_, f, this),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdComplex::
XsdComplex (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  real_ (f, this),
  imaginary_ (f, this),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdComplex::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // real
    //
    if (n.name () == "real" && n.namespace_ ().empty ())
    {
      if (!this->real_)
      {
        this->real_.set (real_traits::create (i, f, this));
        continue;
      }
    }

    // imaginary
    //
    if (n.name () == "imaginary" && n.namespace_ ().empty ())
    {
      if (!this->imaginary_)
      {
        this->imaginary_.set (imaginary_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdComplex* XsdComplex::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdComplex (*this, f, c);
}

XsdComplex::
~XsdComplex ()
{
}

bool
operator== (const XsdComplex& x, const XsdComplex& y)
{
  if (!(x.real () == y.real ()))
    return false;

  if (!(x.imaginary () == y.imaginary ()))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdComplex& x, const XsdComplex& y)
{
  return !(x == y);
}

// XsdSimpleCorrelation
//

XsdSimpleCorrelation::
XsdSimpleCorrelation ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
{
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (const XsdSimpleCorrelation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

XsdSimpleCorrelation* XsdSimpleCorrelation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSimpleCorrelation (*this, f, c);
}

XsdSimpleCorrelation::
~XsdSimpleCorrelation ()
{
}

// XsdCorrelation
//

XsdCorrelation::
XsdCorrelation ()
: ::XsdSimpleCorrelation (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdCorrelation::
XsdCorrelation (const ::xml_schema::double_& _xsd_double__base)
: ::XsdSimpleCorrelation (_xsd_double__base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdCorrelation::
XsdCorrelation (const XsdCorrelation& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleCorrelation (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdCorrelation::
XsdCorrelation (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleCorrelation (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdCorrelation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdCorrelation* XsdCorrelation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdCorrelation (*this, f, c);
}

XsdCorrelation::
~XsdCorrelation ()
{
}

bool
operator== (const XsdCorrelation& x, const XsdCorrelation& y)
{
  if (!(static_cast< const ::XsdSimpleCorrelation& > (x) ==
        static_cast< const ::XsdSimpleCorrelation& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdCorrelation& x, const XsdCorrelation& y)
{
  return !(x == y);
}

// XsdDate
//

XsdDate::
XsdDate ()
: ::xml_schema::date (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDate::
XsdDate (const ::xml_schema::date& _xsd_date_base)
: ::xml_schema::date (_xsd_date_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDate::
XsdDate (const XsdDate& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::date (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdDate::
XsdDate (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::date (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdDate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdDate* XsdDate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDate (*this, f, c);
}

XsdDate::
~XsdDate ()
{
}

bool
operator== (const XsdDate& x, const XsdDate& y)
{
  if (!(static_cast< const ::xml_schema::date& > (x) ==
        static_cast< const ::xml_schema::date& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdDate& x, const XsdDate& y)
{
  return !(x == y);
}

// XsdDateTime
//

XsdDateTime::
XsdDateTime ()
: ::xml_schema::date_time (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDateTime::
XsdDateTime (const ::xml_schema::date_time& _xsd_date_time_base)
: ::xml_schema::date_time (_xsd_date_time_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDateTime::
XsdDateTime (const XsdDateTime& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::date_time (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdDateTime::
XsdDateTime (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::date_time (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdDateTime::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdDateTime* XsdDateTime::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDateTime (*this, f, c);
}

XsdDateTime::
~XsdDateTime ()
{
}

bool
operator== (const XsdDateTime& x, const XsdDateTime& y)
{
  if (!(static_cast< const ::xml_schema::date_time& > (x) ==
        static_cast< const ::xml_schema::date_time& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdDateTime& x, const XsdDateTime& y)
{
  return !(x == y);
}

// XsdDouble
//

XsdDouble::
XsdDouble ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDouble::
XsdDouble (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDouble::
XsdDouble (const XsdDouble& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdDouble::
XsdDouble (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdDouble::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdDouble* XsdDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDouble (*this, f, c);
}

XsdDouble::
~XsdDouble ()
{
}

bool
operator== (const XsdDouble& x, const XsdDouble& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdDouble& x, const XsdDouble& y)
{
  return !(x == y);
}

// XsdDuration
//

XsdDuration::
XsdDuration ()
: ::xml_schema::duration (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDuration::
XsdDuration (const ::xml_schema::duration& _xsd_duration_base)
: ::xml_schema::duration (_xsd_duration_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdDuration::
XsdDuration (const XsdDuration& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::duration (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdDuration::
XsdDuration (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::duration (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdDuration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdDuration* XsdDuration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDuration (*this, f, c);
}

XsdDuration::
~XsdDuration ()
{
}

bool
operator== (const XsdDuration& x, const XsdDuration& y)
{
  if (!(static_cast< const ::xml_schema::duration& > (x) ==
        static_cast< const ::xml_schema::duration& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdDuration& x, const XsdDuration& y)
{
  return !(x == y);
}

// XsdInteger
//

XsdInteger::
XsdInteger ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdInteger::
XsdInteger (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdInteger::
XsdInteger (const XsdInteger& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdInteger::
XsdInteger (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdInteger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdInteger* XsdInteger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdInteger (*this, f, c);
}

XsdInteger::
~XsdInteger ()
{
}

bool
operator== (const XsdInteger& x, const XsdInteger& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdInteger& x, const XsdInteger& y)
{
  return !(x == y);
}

// XsdSimpleNonNegativeDouble
//

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
{
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (const XsdSimpleNonNegativeDouble& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (const ::std::string& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

XsdSimpleNonNegativeDouble* XsdSimpleNonNegativeDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSimpleNonNegativeDouble (*this, f, c);
}

XsdSimpleNonNegativeDouble::
~XsdSimpleNonNegativeDouble ()
{
}

// XsdNonNegativeDouble
//

XsdNonNegativeDouble::
XsdNonNegativeDouble ()
: ::XsdSimpleNonNegativeDouble (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdNonNegativeDouble::
XsdNonNegativeDouble (const ::xml_schema::double_& _xsd_double__base)
: ::XsdSimpleNonNegativeDouble (_xsd_double__base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdNonNegativeDouble::
XsdNonNegativeDouble (const XsdNonNegativeDouble& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::XsdSimpleNonNegativeDouble (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdNonNegativeDouble::
XsdNonNegativeDouble (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::XsdSimpleNonNegativeDouble (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdNonNegativeDouble::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdNonNegativeDouble* XsdNonNegativeDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdNonNegativeDouble (*this, f, c);
}

XsdNonNegativeDouble::
~XsdNonNegativeDouble ()
{
}

bool
operator== (const XsdNonNegativeDouble& x, const XsdNonNegativeDouble& y)
{
  if (!(static_cast< const ::XsdSimpleNonNegativeDouble& > (x) ==
        static_cast< const ::XsdSimpleNonNegativeDouble& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdNonNegativeDouble& x, const XsdNonNegativeDouble& y)
{
  return !(x == y);
}

// XsdNonNegativeInteger
//

XsdNonNegativeInteger::
XsdNonNegativeInteger ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdNonNegativeInteger::
XsdNonNegativeInteger (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdNonNegativeInteger::
XsdNonNegativeInteger (const XsdNonNegativeInteger& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdNonNegativeInteger::
XsdNonNegativeInteger (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdNonNegativeInteger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdNonNegativeInteger* XsdNonNegativeInteger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdNonNegativeInteger (*this, f, c);
}

XsdNonNegativeInteger::
~XsdNonNegativeInteger ()
{
}

bool
operator== (const XsdNonNegativeInteger& x, const XsdNonNegativeInteger& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdNonNegativeInteger& x, const XsdNonNegativeInteger& y)
{
  return !(x == y);
}

// XsdPositiveInteger
//

XsdPositiveInteger::
XsdPositiveInteger ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdPositiveInteger::
XsdPositiveInteger (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdPositiveInteger::
XsdPositiveInteger (const XsdPositiveInteger& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdPositiveInteger::
XsdPositiveInteger (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdPositiveInteger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdPositiveInteger* XsdPositiveInteger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdPositiveInteger (*this, f, c);
}

XsdPositiveInteger::
~XsdPositiveInteger ()
{
}

bool
operator== (const XsdPositiveInteger& x, const XsdPositiveInteger& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdPositiveInteger& x, const XsdPositiveInteger& y)
{
  return !(x == y);
}

// XsdSimplePositiveDouble
//

XsdSimplePositiveDouble::
XsdSimplePositiveDouble ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
{
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (const XsdSimplePositiveDouble& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (const ::std::string& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

XsdSimplePositiveDouble* XsdSimplePositiveDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSimplePositiveDouble (*this, f, c);
}

XsdSimplePositiveDouble::
~XsdSimplePositiveDouble ()
{
}

// XsdPositiveDouble
//

XsdPositiveDouble::
XsdPositiveDouble ()
: ::XsdSimplePositiveDouble (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdPositiveDouble::
XsdPositiveDouble (const ::xml_schema::double_& _xsd_double__base)
: ::XsdSimplePositiveDouble (_xsd_double__base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdPositiveDouble::
XsdPositiveDouble (const XsdPositiveDouble& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdSimplePositiveDouble (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdPositiveDouble::
XsdPositiveDouble (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdSimplePositiveDouble (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdPositiveDouble::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdPositiveDouble* XsdPositiveDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdPositiveDouble (*this, f, c);
}

XsdPositiveDouble::
~XsdPositiveDouble ()
{
}

bool
operator== (const XsdPositiveDouble& x, const XsdPositiveDouble& y)
{
  if (!(static_cast< const ::XsdSimplePositiveDouble& > (x) ==
        static_cast< const ::XsdSimplePositiveDouble& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdPositiveDouble& x, const XsdPositiveDouble& y)
{
  return !(x == y);
}

// XsdSimpleProbability
//

XsdSimpleProbability::
XsdSimpleProbability ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
{
}

XsdSimpleProbability::
XsdSimpleProbability (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

XsdSimpleProbability::
XsdSimpleProbability (const XsdSimpleProbability& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

XsdSimpleProbability::
XsdSimpleProbability (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

XsdSimpleProbability::
XsdSimpleProbability (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

XsdSimpleProbability::
XsdSimpleProbability (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

XsdSimpleProbability* XsdSimpleProbability::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSimpleProbability (*this, f, c);
}

XsdSimpleProbability::
~XsdSimpleProbability ()
{
}

// XsdProbability
//

XsdProbability::
XsdProbability ()
: ::XsdSimpleProbability (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdProbability::
XsdProbability (const ::xml_schema::double_& _xsd_double__base)
: ::XsdSimpleProbability (_xsd_double__base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdProbability::
XsdProbability (const XsdProbability& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleProbability (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdProbability::
XsdProbability (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleProbability (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdProbability::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdProbability* XsdProbability::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdProbability (*this, f, c);
}

XsdProbability::
~XsdProbability ()
{
}

bool
operator== (const XsdProbability& x, const XsdProbability& y)
{
  if (!(static_cast< const ::XsdSimpleProbability& > (x) ==
        static_cast< const ::XsdSimpleProbability& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdProbability& x, const XsdProbability& y)
{
  return !(x == y);
}

// XsdString
//

XsdString::
XsdString ()
: ::xml_schema::string (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdString::
XsdString (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdString::
XsdString (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdString::
XsdString (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdString::
XsdString (const XsdString& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdString::
XsdString (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdString::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdString* XsdString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdString (*this, f, c);
}

XsdString::
~XsdString ()
{
}

bool
operator== (const XsdString& x, const XsdString& y)
{
  if (!(static_cast< const ::xml_schema::string& > (x) ==
        static_cast< const ::xml_schema::string& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdString& x, const XsdString& y)
{
  return !(x == y);
}

// XsdUnsignedInteger
//

XsdUnsignedInteger::
XsdUnsignedInteger ()
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdUnsignedInteger::
XsdUnsignedInteger (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base),
  refID_ (::xml_schema::flags (), this),
  xpath_ (::xml_schema::flags (), this),
  result_ (result_default_value (), ::xml_schema::flags (), this)
{
}

XsdUnsignedInteger::
XsdUnsignedInteger (const XsdUnsignedInteger& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c),
  refID_ (x.refID_, f, this),
  xpath_ (x.xpath_, f, this),
  result_ (x.result_, f, this)
{
}

XsdUnsignedInteger::
XsdUnsignedInteger (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void XsdUnsignedInteger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "refID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< refID_type > r (
        refID_traits::create (i, f, this));

      this->refID_.set (r);
      continue;
    }

    if (n.name () == "xpath" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xpath_type > r (
        xpath_traits::create (i, f, this));

      this->xpath_.set (r);
      continue;
    }

    if (n.name () == "result" && n.namespace_ ().empty ())
    {
      this->result_.set (result_traits::create (i, f, this));
      continue;
    }
  }

  if (!result_.present ())
  {
    this->result_.set (result_default_value ());
  }
}

XsdUnsignedInteger* XsdUnsignedInteger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdUnsignedInteger (*this, f, c);
}

XsdUnsignedInteger::
~XsdUnsignedInteger ()
{
}

bool
operator== (const XsdUnsignedInteger& x, const XsdUnsignedInteger& y)
{
  if (!(static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (x) ==
        static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (y)))
    return false;

  if (!(x.refID () == y.refID ()))
    return false;

  if (!(x.xpath () == y.xpath ()))
    return false;

  if (!(x.result () == y.result ()))
    return false;

  return true;
}

bool
operator!= (const XsdUnsignedInteger& x, const XsdUnsignedInteger& y)
{
  return !(x == y);
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdBoolean& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdComplex& i)
{
  if (i.real ())
  {
    o << ::std::endl << "real: " << *i.real ();
  }

  if (i.imaginary ())
  {
    o << ::std::endl << "imaginary: " << *i.imaginary ();
  }

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSimpleCorrelation& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdCorrelation& i)
{
  o << static_cast< const ::XsdSimpleCorrelation& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDate& i)
{
  o << static_cast< const ::xml_schema::date& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDateTime& i)
{
  o << static_cast< const ::xml_schema::date_time& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDouble& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDuration& i)
{
  o << static_cast< const ::xml_schema::duration& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdInteger& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSimpleNonNegativeDouble& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdNonNegativeDouble& i)
{
  o << static_cast< const ::XsdSimpleNonNegativeDouble& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdNonNegativeInteger& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdPositiveInteger& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSimplePositiveDouble& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdPositiveDouble& i)
{
  o << static_cast< const ::XsdSimplePositiveDouble& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSimpleProbability& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdProbability& i)
{
  o << static_cast< const ::XsdSimpleProbability& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdString& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdUnsignedInteger& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);

  if (i.refID ())
  {
    o << ::std::endl << "refID: " << *i.refID ();
  }

  if (i.xpath ())
  {
    o << ::std::endl << "xpath: " << *i.xpath ();
  }

  o << ::std::endl << "result: " << i.result ();
  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (xercesc::DOMElement& e, const XsdBoolean& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdComplex& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // real
  //
  if (i.real ())
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "real",
        e));

    s << ::xml_schema::as_double(*i.real ());
  }

  // imaginary
  //
  if (i.imaginary ())
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "imaginary",
        e));

    s << ::xml_schema::as_double(*i.imaginary ());
  }

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdSimpleCorrelation& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSimpleCorrelation& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSimpleCorrelation& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdCorrelation& i)
{
  e << static_cast< const ::XsdSimpleCorrelation& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdDate& i)
{
  e << static_cast< const ::xml_schema::date& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdDateTime& i)
{
  e << static_cast< const ::xml_schema::date_time& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdDouble& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdDuration& i)
{
  e << static_cast< const ::xml_schema::duration& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdInteger& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdSimpleNonNegativeDouble& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSimpleNonNegativeDouble& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSimpleNonNegativeDouble& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdNonNegativeDouble& i)
{
  e << static_cast< const ::XsdSimpleNonNegativeDouble& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdNonNegativeInteger& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdPositiveInteger& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdSimplePositiveDouble& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSimplePositiveDouble& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSimplePositiveDouble& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdPositiveDouble& i)
{
  e << static_cast< const ::XsdSimplePositiveDouble& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdSimpleProbability& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSimpleProbability& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSimpleProbability& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdProbability& i)
{
  e << static_cast< const ::XsdSimpleProbability& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdString& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

void
operator<< (xercesc::DOMElement& e, const XsdUnsignedInteger& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);

  // refID
  //
  if (i.refID ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "refID",
        e));

    a << *i.refID ();
  }

  // xpath
  //
  if (i.xpath ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xpath",
        e));

    a << *i.xpath ();
  }

  // result
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "result",
        e));

    a << i.result ();
  }
}

#include <xsd/cxx/tree/stream-extraction-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::stream_extraction_plate< 0, boost::archive::binary_iarchive, char >
  stream_extraction_plate_init_0;
}

XsdBoolean::
XsdBoolean (::xml_schema::istream< boost::archive::binary_iarchive >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdBoolean::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdComplex::
XsdComplex (::xml_schema::istream< boost::archive::binary_iarchive >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (s, f, c),
  real_ (f, this),
  imaginary_ (f, this),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdComplex::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      real_type r;
      s >> r;
      this->real_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      imaginary_type r;
      s >> r;
      this->imaginary_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdSimpleCorrelation::
XsdSimpleCorrelation (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
{
}

XsdCorrelation::
XsdCorrelation (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleCorrelation (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdCorrelation::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdDate::
XsdDate (::xml_schema::istream< boost::archive::binary_iarchive >& s,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::date (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdDate::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdDateTime::
XsdDateTime (::xml_schema::istream< boost::archive::binary_iarchive >& s,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::date_time (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdDateTime::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdDouble::
XsdDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdDouble::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdDuration::
XsdDuration (::xml_schema::istream< boost::archive::binary_iarchive >& s,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::duration (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdDuration::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdInteger::
XsdInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdInteger::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdSimpleNonNegativeDouble::
XsdSimpleNonNegativeDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
{
}

XsdNonNegativeDouble::
XsdNonNegativeDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::XsdSimpleNonNegativeDouble (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdNonNegativeDouble::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdNonNegativeInteger::
XsdNonNegativeInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdNonNegativeInteger::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdPositiveInteger::
XsdPositiveInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdPositiveInteger::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdSimplePositiveDouble::
XsdSimplePositiveDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
{
}

XsdPositiveDouble::
XsdPositiveDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdSimplePositiveDouble (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdPositiveDouble::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdSimpleProbability::
XsdSimpleProbability (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
{
}

XsdProbability::
XsdProbability (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdSimpleProbability (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdProbability::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdString::
XsdString (::xml_schema::istream< boost::archive::binary_iarchive >& s,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdString::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

XsdUnsignedInteger::
XsdUnsignedInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, f, c),
  refID_ (f, this),
  xpath_ (f, this),
  result_ (f, this)
{
  this->parse (s, f);
}

void XsdUnsignedInteger::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< refID_type > r (new refID_type (s, f, this));
      this->refID_.set (r);
    }
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< xpath_type > r (new xpath_type (s, f, this));
      this->xpath_.set (r);
    }
  }

  {
    result_type r;
    s >> r;
    this->result_.set (r);
  }
}

#include <xsd/cxx/tree/stream-insertion-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::stream_insertion_plate< 0, boost::archive::binary_oarchive, char >
  stream_insertion_plate_init_0;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdBoolean& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdComplex& x)
{
  {
    bool p (x.real ());
    s << p;
    if (p)
      s << *x.real ();
  }

  {
    bool p (x.imaginary ());
    s << p;
    if (p)
      s << *x.imaginary ();
  }

  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdSimpleCorrelation& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdCorrelation& x)
{
  s << static_cast< const ::XsdSimpleCorrelation& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDate& x)
{
  s << static_cast< const ::xml_schema::date& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDateTime& x)
{
  s << static_cast< const ::xml_schema::date_time& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDouble& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDuration& x)
{
  s << static_cast< const ::xml_schema::duration& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdInteger& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdSimpleNonNegativeDouble& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdNonNegativeDouble& x)
{
  s << static_cast< const ::XsdSimpleNonNegativeDouble& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdNonNegativeInteger& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdPositiveInteger& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdSimplePositiveDouble& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdPositiveDouble& x)
{
  s << static_cast< const ::XsdSimplePositiveDouble& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdSimpleProbability& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdProbability& x)
{
  s << static_cast< const ::XsdSimpleProbability& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdString& x)
{
  s << static_cast< const ::xml_schema::string& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdUnsignedInteger& x)
{
  s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (x);
  {
    bool p (x.refID ());
    s << p;
    if (p)
      s << *x.refID ();
  }

  {
    bool p (x.xpath ());
    s << p;
    if (p)
      s << *x.xpath ();
  }

  s << x.result ();
  return s;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

