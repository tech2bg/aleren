// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_CORE_INPUT_HXX
#define CXX___SCHEMA_XSD_CORE_INPUT_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdInputDocument;
class XsdInputRules;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "types.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "types.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdInputDocument: public ::xml_schema::type
{
  public:
  // schema
  // 
  typedef ::XsdBaseSchema schema_type;
  typedef ::xsd::cxx::tree::sequence< schema_type > schema_sequence;
  typedef xsd::cxx::tree::sequence< schema_type >::iterator schema_iterator;
  typedef xsd::cxx::tree::sequence< schema_type >::const_iterator schema_const_iterator;
  typedef ::xsd::cxx::tree::traits< schema_type, char > schema_traits;

  const schema_sequence&
  schema () const;

  schema_sequence&
  schema ();

  void
  schema (const schema_sequence& s);

  // rules
  // 
  typedef ::XsdInputRules rules_type;
  typedef ::xsd::cxx::tree::optional< rules_type > rules_optional;
  typedef ::xsd::cxx::tree::traits< rules_type, char > rules_traits;

  const rules_optional&
  rules () const;

  rules_optional&
  rules ();

  void
  rules (const rules_type& x);

  void
  rules (const rules_optional& x);

  void
  rules (::std::auto_ptr< rules_type > p);

  // name
  // 
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // client
  // 
  typedef ::xml_schema::string client_type;
  typedef ::xsd::cxx::tree::optional< client_type > client_optional;
  typedef ::xsd::cxx::tree::traits< client_type, char > client_traits;

  const client_optional&
  client () const;

  client_optional&
  client ();

  void
  client (const client_type& x);

  void
  client (const client_optional& x);

  void
  client (::std::auto_ptr< client_type > p);

  // timeStamp
  // 
  typedef ::xml_schema::date_time timeStamp_type;
  typedef ::xsd::cxx::tree::optional< timeStamp_type > timeStamp_optional;
  typedef ::xsd::cxx::tree::traits< timeStamp_type, char > timeStamp_traits;

  const timeStamp_optional&
  timeStamp () const;

  timeStamp_optional&
  timeStamp ();

  void
  timeStamp (const timeStamp_type& x);

  void
  timeStamp (const timeStamp_optional& x);

  void
  timeStamp (::std::auto_ptr< timeStamp_type > p);

  // documentID
  // 
  typedef ::xml_schema::id documentID_type;
  typedef ::xsd::cxx::tree::traits< documentID_type, char > documentID_traits;

  const documentID_type&
  documentID () const;

  documentID_type&
  documentID ();

  void
  documentID (const documentID_type& x);

  void
  documentID (::std::auto_ptr< documentID_type > p);

  // Constructors.
  //
  XsdInputDocument ();

  XsdInputDocument (const documentID_type&);

  XsdInputDocument (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdInputDocument (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdInputDocument (const XsdInputDocument& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdInputDocument*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdInputDocument ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  schema_sequence schema_;
  rules_optional rules_;
  name_optional name_;
  client_optional client_;
  timeStamp_optional timeStamp_;
  ::xsd::cxx::tree::one< documentID_type > documentID_;
};

bool
operator== (const XsdInputDocument&, const XsdInputDocument&);

bool
operator!= (const XsdInputDocument&, const XsdInputDocument&);


class XsdInputRules: public ::xml_schema::type
{
  public:
  // resolveDependenciesAtInsertion
  // 
  typedef ::xml_schema::boolean resolveDependenciesAtInsertion_type;
  typedef ::xsd::cxx::tree::optional< resolveDependenciesAtInsertion_type > resolveDependenciesAtInsertion_optional;
  typedef ::xsd::cxx::tree::traits< resolveDependenciesAtInsertion_type, char > resolveDependenciesAtInsertion_traits;

  const resolveDependenciesAtInsertion_optional&
  resolveDependenciesAtInsertion () const;

  resolveDependenciesAtInsertion_optional&
  resolveDependenciesAtInsertion ();

  void
  resolveDependenciesAtInsertion (const resolveDependenciesAtInsertion_type& x);

  void
  resolveDependenciesAtInsertion (const resolveDependenciesAtInsertion_optional& x);

  static resolveDependenciesAtInsertion_type
  resolveDependenciesAtInsertion_default_value ();

  // allowUniqueIDOverwrite
  // 
  typedef ::xml_schema::boolean allowUniqueIDOverwrite_type;
  typedef ::xsd::cxx::tree::optional< allowUniqueIDOverwrite_type > allowUniqueIDOverwrite_optional;
  typedef ::xsd::cxx::tree::traits< allowUniqueIDOverwrite_type, char > allowUniqueIDOverwrite_traits;

  const allowUniqueIDOverwrite_optional&
  allowUniqueIDOverwrite () const;

  allowUniqueIDOverwrite_optional&
  allowUniqueIDOverwrite ();

  void
  allowUniqueIDOverwrite (const allowUniqueIDOverwrite_type& x);

  void
  allowUniqueIDOverwrite (const allowUniqueIDOverwrite_optional& x);

  // clearCacheAfterProcessing
  // 
  typedef ::xml_schema::boolean clearCacheAfterProcessing_type;
  typedef ::xsd::cxx::tree::optional< clearCacheAfterProcessing_type > clearCacheAfterProcessing_optional;
  typedef ::xsd::cxx::tree::traits< clearCacheAfterProcessing_type, char > clearCacheAfterProcessing_traits;

  const clearCacheAfterProcessing_optional&
  clearCacheAfterProcessing () const;

  clearCacheAfterProcessing_optional&
  clearCacheAfterProcessing ();

  void
  clearCacheAfterProcessing (const clearCacheAfterProcessing_type& x);

  void
  clearCacheAfterProcessing (const clearCacheAfterProcessing_optional& x);

  static clearCacheAfterProcessing_type
  clearCacheAfterProcessing_default_value ();

  // includeCallStackInErrorMessages
  // 
  typedef ::xml_schema::boolean includeCallStackInErrorMessages_type;
  typedef ::xsd::cxx::tree::optional< includeCallStackInErrorMessages_type > includeCallStackInErrorMessages_optional;
  typedef ::xsd::cxx::tree::traits< includeCallStackInErrorMessages_type, char > includeCallStackInErrorMessages_traits;

  const includeCallStackInErrorMessages_optional&
  includeCallStackInErrorMessages () const;

  includeCallStackInErrorMessages_optional&
  includeCallStackInErrorMessages ();

  void
  includeCallStackInErrorMessages (const includeCallStackInErrorMessages_type& x);

  void
  includeCallStackInErrorMessages (const includeCallStackInErrorMessages_optional& x);

  static includeCallStackInErrorMessages_type
  includeCallStackInErrorMessages_default_value ();

  // Constructors.
  //
  XsdInputRules ();

  XsdInputRules (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdInputRules (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdInputRules (const XsdInputRules& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdInputRules*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdInputRules ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  resolveDependenciesAtInsertion_optional resolveDependenciesAtInsertion_;
  allowUniqueIDOverwrite_optional allowUniqueIDOverwrite_;
  clearCacheAfterProcessing_optional clearCacheAfterProcessing_;
  includeCallStackInErrorMessages_optional includeCallStackInErrorMessages_;
};

bool
operator== (const XsdInputRules&, const XsdInputRules&);

bool
operator!= (const XsdInputRules&, const XsdInputRules&);


#ifndef XSD_DONT_INCLUDE_INLINE

#include "types.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const XsdInputDocument&);

::std::ostream&
operator<< (::std::ostream&, const XsdInputRules&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (const ::std::string& uri,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (const ::std::string& uri,
                  ::xml_schema::error_handler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (const ::std::string& uri,
                  xercesc::DOMErrorHandler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  ::xml_schema::error_handler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  xercesc::DOMErrorHandler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  const ::std::string& id,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  const ::std::string& id,
                  ::xml_schema::error_handler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::std::istream& is,
                  const ::std::string& id,
                  xercesc::DOMErrorHandler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (xercesc::InputSource& is,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (xercesc::InputSource& is,
                  ::xml_schema::error_handler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (xercesc::InputSource& is,
                  xercesc::DOMErrorHandler& eh,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (const xercesc::DOMDocument& d,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdInputDocument >
xsdInputDocument (::xml_schema::dom::auto_ptr< xercesc::DOMDocument >& d,
                  ::xml_schema::flags f = 0,
                  const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdInputDocument&);

void
operator<< (xercesc::DOMElement&, const XsdInputRules&);

// Serialize to std::ostream.
//

void
xsdInputDocument (::std::ostream& os,
                  const ::XsdInputDocument& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

void
xsdInputDocument (::std::ostream& os,
                  const ::XsdInputDocument& x, 
                  ::xml_schema::error_handler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

void
xsdInputDocument (::std::ostream& os,
                  const ::XsdInputDocument& x, 
                  xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
xsdInputDocument (xercesc::XMLFormatTarget& ft,
                  const ::XsdInputDocument& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

void
xsdInputDocument (xercesc::XMLFormatTarget& ft,
                  const ::XsdInputDocument& x, 
                  ::xml_schema::error_handler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

void
xsdInputDocument (xercesc::XMLFormatTarget& ft,
                  const ::XsdInputDocument& x, 
                  xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
xsdInputDocument (xercesc::DOMDocument& d,
                  const ::XsdInputDocument& x,
                  ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< xercesc::DOMDocument >
xsdInputDocument (const ::XsdInputDocument& x, 
                  const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                  ::xml_schema::flags f = 0);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdInputDocument&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdInputRules&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "input.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_CORE_INPUT_HXX
