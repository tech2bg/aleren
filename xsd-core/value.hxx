// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_CORE_VALUE_HXX
#define CXX___SCHEMA_XSD_CORE_VALUE_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdBoolean;
class XsdComplex;
class XsdSimpleCorrelation;
class XsdCorrelation;
class XsdDate;
class XsdDateTime;
class XsdDouble;
class XsdDuration;
class XsdInteger;
class XsdSimpleNonNegativeDouble;
class XsdNonNegativeDouble;
class XsdNonNegativeInteger;
class XsdPositiveInteger;
class XsdSimplePositiveDouble;
class XsdPositiveDouble;
class XsdSimpleProbability;
class XsdProbability;
class XsdString;
class XsdUnsignedInteger;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#undef XSD_DONT_INCLUDE_INLINE
#else

#endif // XSD_DONT_INCLUDE_INLINE

class XsdBoolean: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdBoolean ();

  XsdBoolean (const ::xml_schema::boolean&);

  XsdBoolean (::xml_schema::istream< boost::archive::binary_iarchive >& s,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdBoolean (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdBoolean (const XsdBoolean& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual XsdBoolean*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdBoolean ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdBoolean&, const XsdBoolean&);

bool
operator!= (const XsdBoolean&, const XsdBoolean&);


class XsdComplex: public ::xml_schema::type
{
  public:
  // real
  // 
  typedef ::xml_schema::double_ real_type;
  typedef ::xsd::cxx::tree::optional< real_type > real_optional;
  typedef ::xsd::cxx::tree::traits< real_type, char, ::xsd::cxx::tree::schema_type::double_ > real_traits;

  const real_optional&
  real () const;

  real_optional&
  real ();

  void
  real (const real_type& x);

  void
  real (const real_optional& x);

  static real_type
  real_default_value ();

  // imaginary
  // 
  typedef ::xml_schema::double_ imaginary_type;
  typedef ::xsd::cxx::tree::optional< imaginary_type > imaginary_optional;
  typedef ::xsd::cxx::tree::traits< imaginary_type, char, ::xsd::cxx::tree::schema_type::double_ > imaginary_traits;

  const imaginary_optional&
  imaginary () const;

  imaginary_optional&
  imaginary ();

  void
  imaginary (const imaginary_type& x);

  void
  imaginary (const imaginary_optional& x);

  static imaginary_type
  imaginary_default_value ();

  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdComplex ();

  XsdComplex (::xml_schema::istream< boost::archive::binary_iarchive >& s,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdComplex (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdComplex (const XsdComplex& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual XsdComplex*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdComplex ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  real_optional real_;
  imaginary_optional imaginary_;
  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdComplex&, const XsdComplex&);

bool
operator!= (const XsdComplex&, const XsdComplex&);


class XsdSimpleCorrelation: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  XsdSimpleCorrelation ();

  XsdSimpleCorrelation (const ::xml_schema::double_&);

  XsdSimpleCorrelation (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleCorrelation (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleCorrelation (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleCorrelation (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleCorrelation (const XsdSimpleCorrelation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdSimpleCorrelation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdSimpleCorrelation ();
};

class XsdCorrelation: public ::XsdSimpleCorrelation
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdCorrelation ();

  XsdCorrelation (const ::xml_schema::double_&);

  XsdCorrelation (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdCorrelation (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdCorrelation (const XsdCorrelation& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdCorrelation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdCorrelation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdCorrelation&, const XsdCorrelation&);

bool
operator!= (const XsdCorrelation&, const XsdCorrelation&);


class XsdDate: public ::xml_schema::date
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdDate ();

  XsdDate (const ::xml_schema::date&);

  XsdDate (::xml_schema::istream< boost::archive::binary_iarchive >& s,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  XsdDate (const xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  XsdDate (const XsdDate& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual XsdDate*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDate ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdDate&, const XsdDate&);

bool
operator!= (const XsdDate&, const XsdDate&);


class XsdDateTime: public ::xml_schema::date_time
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdDateTime ();

  XsdDateTime (const ::xml_schema::date_time&);

  XsdDateTime (::xml_schema::istream< boost::archive::binary_iarchive >& s,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  XsdDateTime (const xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  XsdDateTime (const XsdDateTime& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual XsdDateTime*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDateTime ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdDateTime&, const XsdDateTime&);

bool
operator!= (const XsdDateTime&, const XsdDateTime&);


class XsdDouble: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdDouble ();

  XsdDouble (const ::xml_schema::double_&);

  XsdDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdDouble (const xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdDouble (const XsdDouble& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual XsdDouble*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDouble ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdDouble&, const XsdDouble&);

bool
operator!= (const XsdDouble&, const XsdDouble&);


class XsdDuration: public ::xml_schema::duration
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdDuration ();

  XsdDuration (const ::xml_schema::duration&);

  XsdDuration (::xml_schema::istream< boost::archive::binary_iarchive >& s,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  XsdDuration (const xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  XsdDuration (const XsdDuration& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual XsdDuration*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdDuration ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdDuration&, const XsdDuration&);

bool
operator!= (const XsdDuration&, const XsdDuration&);


class XsdInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdInteger ();

  XsdInteger (const ::xml_schema::integer&);

  XsdInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdInteger (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  XsdInteger (const XsdInteger& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual XsdInteger*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdInteger ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdInteger&, const XsdInteger&);

bool
operator!= (const XsdInteger&, const XsdInteger&);


class XsdSimpleNonNegativeDouble: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  XsdSimpleNonNegativeDouble ();

  XsdSimpleNonNegativeDouble (const ::xml_schema::double_&);

  XsdSimpleNonNegativeDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  XsdSimpleNonNegativeDouble (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  XsdSimpleNonNegativeDouble (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  XsdSimpleNonNegativeDouble (const ::std::string& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  XsdSimpleNonNegativeDouble (const XsdSimpleNonNegativeDouble& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual XsdSimpleNonNegativeDouble*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdSimpleNonNegativeDouble ();
};

class XsdNonNegativeDouble: public ::XsdSimpleNonNegativeDouble
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdNonNegativeDouble ();

  XsdNonNegativeDouble (const ::xml_schema::double_&);

  XsdNonNegativeDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdNonNegativeDouble (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdNonNegativeDouble (const XsdNonNegativeDouble& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdNonNegativeDouble*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdNonNegativeDouble ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdNonNegativeDouble&, const XsdNonNegativeDouble&);

bool
operator!= (const XsdNonNegativeDouble&, const XsdNonNegativeDouble&);


class XsdNonNegativeInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdNonNegativeInteger ();

  XsdNonNegativeInteger (const ::xml_schema::non_negative_integer&);

  XsdNonNegativeInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdNonNegativeInteger (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdNonNegativeInteger (const XsdNonNegativeInteger& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual XsdNonNegativeInteger*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdNonNegativeInteger ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdNonNegativeInteger&, const XsdNonNegativeInteger&);

bool
operator!= (const XsdNonNegativeInteger&, const XsdNonNegativeInteger&);


class XsdPositiveInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdPositiveInteger ();

  XsdPositiveInteger (const ::xml_schema::positive_integer&);

  XsdPositiveInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdPositiveInteger (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdPositiveInteger (const XsdPositiveInteger& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdPositiveInteger*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdPositiveInteger ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdPositiveInteger&, const XsdPositiveInteger&);

bool
operator!= (const XsdPositiveInteger&, const XsdPositiveInteger&);


class XsdSimplePositiveDouble: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  XsdSimplePositiveDouble ();

  XsdSimplePositiveDouble (const ::xml_schema::double_&);

  XsdSimplePositiveDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdSimplePositiveDouble (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdSimplePositiveDouble (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdSimplePositiveDouble (const ::std::string& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdSimplePositiveDouble (const XsdSimplePositiveDouble& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual XsdSimplePositiveDouble*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdSimplePositiveDouble ();
};

class XsdPositiveDouble: public ::XsdSimplePositiveDouble
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdPositiveDouble ();

  XsdPositiveDouble (const ::xml_schema::double_&);

  XsdPositiveDouble (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdPositiveDouble (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdPositiveDouble (const XsdPositiveDouble& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdPositiveDouble*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdPositiveDouble ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdPositiveDouble&, const XsdPositiveDouble&);

bool
operator!= (const XsdPositiveDouble&, const XsdPositiveDouble&);


class XsdSimpleProbability: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  XsdSimpleProbability ();

  XsdSimpleProbability (const ::xml_schema::double_&);

  XsdSimpleProbability (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleProbability (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleProbability (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleProbability (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSimpleProbability (const XsdSimpleProbability& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdSimpleProbability*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdSimpleProbability ();
};

class XsdProbability: public ::XsdSimpleProbability
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdProbability ();

  XsdProbability (const ::xml_schema::double_&);

  XsdProbability (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdProbability (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdProbability (const XsdProbability& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdProbability*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdProbability ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdProbability&, const XsdProbability&);

bool
operator!= (const XsdProbability&, const XsdProbability&);


class XsdString: public ::xml_schema::string
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdString ();

  XsdString (const char*);

  XsdString (const ::std::string&);

  XsdString (const ::xml_schema::string&);

  XsdString (::xml_schema::istream< boost::archive::binary_iarchive >& s,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdString (const xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  XsdString (const XsdString& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual XsdString*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdString ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdString&, const XsdString&);

bool
operator!= (const XsdString&, const XsdString&);


class XsdUnsignedInteger: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
{
  public:
  // refID
  // 
  typedef ::xml_schema::idref refID_type;
  typedef ::xsd::cxx::tree::optional< refID_type > refID_optional;
  typedef ::xsd::cxx::tree::traits< refID_type, char > refID_traits;

  const refID_optional&
  refID () const;

  refID_optional&
  refID ();

  void
  refID (const refID_type& x);

  void
  refID (const refID_optional& x);

  void
  refID (::std::auto_ptr< refID_type > p);

  // xpath
  // 
  typedef ::xml_schema::string xpath_type;
  typedef ::xsd::cxx::tree::optional< xpath_type > xpath_optional;
  typedef ::xsd::cxx::tree::traits< xpath_type, char > xpath_traits;

  const xpath_optional&
  xpath () const;

  xpath_optional&
  xpath ();

  void
  xpath (const xpath_type& x);

  void
  xpath (const xpath_optional& x);

  void
  xpath (::std::auto_ptr< xpath_type > p);

  // result
  // 
  typedef ::xml_schema::boolean result_type;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_type&
  result () const;

  result_type&
  result ();

  void
  result (const result_type& x);

  static result_type
  result_default_value ();

  // Constructors.
  //
  XsdUnsignedInteger ();

  XsdUnsignedInteger (const ::xml_schema::unsigned_int&);

  XsdUnsignedInteger (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdUnsignedInteger (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdUnsignedInteger (const XsdUnsignedInteger& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdUnsignedInteger*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdUnsignedInteger ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  refID_optional refID_;
  xpath_optional xpath_;
  ::xsd::cxx::tree::one< result_type > result_;
};

bool
operator== (const XsdUnsignedInteger&, const XsdUnsignedInteger&);

bool
operator!= (const XsdUnsignedInteger&, const XsdUnsignedInteger&);


#ifndef XSD_DONT_INCLUDE_INLINE

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const XsdBoolean&);

::std::ostream&
operator<< (::std::ostream&, const XsdComplex&);

::std::ostream&
operator<< (::std::ostream&, const XsdSimpleCorrelation&);

::std::ostream&
operator<< (::std::ostream&, const XsdCorrelation&);

::std::ostream&
operator<< (::std::ostream&, const XsdDate&);

::std::ostream&
operator<< (::std::ostream&, const XsdDateTime&);

::std::ostream&
operator<< (::std::ostream&, const XsdDouble&);

::std::ostream&
operator<< (::std::ostream&, const XsdDuration&);

::std::ostream&
operator<< (::std::ostream&, const XsdInteger&);

::std::ostream&
operator<< (::std::ostream&, const XsdSimpleNonNegativeDouble&);

::std::ostream&
operator<< (::std::ostream&, const XsdNonNegativeDouble&);

::std::ostream&
operator<< (::std::ostream&, const XsdNonNegativeInteger&);

::std::ostream&
operator<< (::std::ostream&, const XsdPositiveInteger&);

::std::ostream&
operator<< (::std::ostream&, const XsdSimplePositiveDouble&);

::std::ostream&
operator<< (::std::ostream&, const XsdPositiveDouble&);

::std::ostream&
operator<< (::std::ostream&, const XsdSimpleProbability&);

::std::ostream&
operator<< (::std::ostream&, const XsdProbability&);

::std::ostream&
operator<< (::std::ostream&, const XsdString&);

::std::ostream&
operator<< (::std::ostream&, const XsdUnsignedInteger&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdBoolean&);

void
operator<< (xercesc::DOMElement&, const XsdComplex&);

void
operator<< (xercesc::DOMElement&, const XsdSimpleCorrelation&);

void
operator<< (xercesc::DOMAttr&, const XsdSimpleCorrelation&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSimpleCorrelation&);

void
operator<< (xercesc::DOMElement&, const XsdCorrelation&);

void
operator<< (xercesc::DOMElement&, const XsdDate&);

void
operator<< (xercesc::DOMElement&, const XsdDateTime&);

void
operator<< (xercesc::DOMElement&, const XsdDouble&);

void
operator<< (xercesc::DOMElement&, const XsdDuration&);

void
operator<< (xercesc::DOMElement&, const XsdInteger&);

void
operator<< (xercesc::DOMElement&, const XsdSimpleNonNegativeDouble&);

void
operator<< (xercesc::DOMAttr&, const XsdSimpleNonNegativeDouble&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSimpleNonNegativeDouble&);

void
operator<< (xercesc::DOMElement&, const XsdNonNegativeDouble&);

void
operator<< (xercesc::DOMElement&, const XsdNonNegativeInteger&);

void
operator<< (xercesc::DOMElement&, const XsdPositiveInteger&);

void
operator<< (xercesc::DOMElement&, const XsdSimplePositiveDouble&);

void
operator<< (xercesc::DOMAttr&, const XsdSimplePositiveDouble&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSimplePositiveDouble&);

void
operator<< (xercesc::DOMElement&, const XsdPositiveDouble&);

void
operator<< (xercesc::DOMElement&, const XsdSimpleProbability&);

void
operator<< (xercesc::DOMAttr&, const XsdSimpleProbability&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSimpleProbability&);

void
operator<< (xercesc::DOMElement&, const XsdProbability&);

void
operator<< (xercesc::DOMElement&, const XsdString&);

void
operator<< (xercesc::DOMElement&, const XsdUnsignedInteger&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdBoolean&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdComplex&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdSimpleCorrelation&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdCorrelation&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDate&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDateTime&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDouble&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdDuration&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdInteger&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdSimpleNonNegativeDouble&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdNonNegativeDouble&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdNonNegativeInteger&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdPositiveInteger&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdSimplePositiveDouble&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdPositiveDouble&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdSimpleProbability&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdProbability&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdString&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdUnsignedInteger&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "value.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_CORE_VALUE_HXX
