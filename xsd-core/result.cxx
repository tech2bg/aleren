// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "precompiled.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "result.hxx"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

// XsdResult
//

XsdResult::
XsdResult ()
: ::xml_schema::type (),
  comment_ (::xml_schema::flags (), this),
  calculationID_ (::xml_schema::flags (), this),
  elapsedTime_ (::xml_schema::flags (), this)
{
}

XsdResult::
XsdResult (const calculationID_type& calculationID)
: ::xml_schema::type (),
  comment_ (::xml_schema::flags (), this),
  calculationID_ (calculationID, ::xml_schema::flags (), this),
  elapsedTime_ (::xml_schema::flags (), this)
{
}

XsdResult::
XsdResult (const XsdResult& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  comment_ (x.comment_, f, this),
  calculationID_ (x.calculationID_, f, this),
  elapsedTime_ (x.elapsedTime_, f, this)
{
}

XsdResult::
XsdResult (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  comment_ (f, this),
  calculationID_ (f, this),
  elapsedTime_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // comment
    //
    if (n.name () == "comment" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< comment_type > r (
        comment_traits::create (i, f, this));

      this->comment_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "calculationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calculationID_type > r (
        calculationID_traits::create (i, f, this));

      this->calculationID_.set (r);
      continue;
    }

    if (n.name () == "elapsedTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elapsedTime_type > r (
        elapsedTime_traits::create (i, f, this));

      this->elapsedTime_.set (r);
      continue;
    }
  }

  if (!calculationID_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "calculationID",
      "");
  }
}

XsdResult* XsdResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdResult (*this, f, c);
}

XsdResult::
~XsdResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdResult >
_xsd_XsdResult_type_factory_init (
  "XsdResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdResult >
_xsd_XsdResult_comparison_init;

bool
operator== (const XsdResult& x, const XsdResult& y)
{
  if (!(x.comment () == y.comment ()))
    return false;

  if (!(x.calculationID () == y.calculationID ()))
    return false;

  if (!(x.elapsedTime () == y.elapsedTime ()))
    return false;

  return true;
}

bool
operator!= (const XsdResult& x, const XsdResult& y)
{
  return !(x == y);
}

// XsdBooleanResult
//

XsdBooleanResult::
XsdBooleanResult ()
: ::XsdResult ()
{
}

XsdBooleanResult::
XsdBooleanResult (const ::XsdResult& _xsd_XsdResult_base)
: ::XsdResult (_xsd_XsdResult_base)
{
}

XsdBooleanResult::
XsdBooleanResult (const calculationID_type& calculationID)
: ::XsdResult (calculationID)
{
}

XsdBooleanResult::
XsdBooleanResult (const XsdBooleanResult& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (x, f, c)
{
}

XsdBooleanResult::
XsdBooleanResult (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (e, f, c)
{
}

XsdBooleanResult* XsdBooleanResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdBooleanResult (*this, f, c);
}

XsdBooleanResult::
~XsdBooleanResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdBooleanResult >
_xsd_XsdBooleanResult_type_factory_init (
  "XsdBooleanResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdBooleanResult >
_xsd_XsdBooleanResult_comparison_init;

// XsdDateResult
//

XsdDateResult::
XsdDateResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdDateResult::
XsdDateResult (const ::XsdResult& _xsd_XsdResult_base,
               const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDateResult::
XsdDateResult (const calculationID_type& calculationID,
               const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDateResult::
XsdDateResult (const XsdDateResult& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdDateResult::
XsdDateResult (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdDateResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdDateResult* XsdDateResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDateResult (*this, f, c);
}

XsdDateResult::
~XsdDateResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdDateResult >
_xsd_XsdDateResult_type_factory_init (
  "XsdDateResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdDateResult >
_xsd_XsdDateResult_comparison_init;

bool
operator== (const XsdDateResult& x, const XsdDateResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdDateResult& x, const XsdDateResult& y)
{
  return !(x == y);
}

// XsdDateTimeResult
//

XsdDateTimeResult::
XsdDateTimeResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdDateTimeResult::
XsdDateTimeResult (const ::XsdResult& _xsd_XsdResult_base,
                   const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDateTimeResult::
XsdDateTimeResult (const calculationID_type& calculationID,
                   const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDateTimeResult::
XsdDateTimeResult (const XsdDateTimeResult& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdDateTimeResult::
XsdDateTimeResult (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdDateTimeResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdDateTimeResult* XsdDateTimeResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDateTimeResult (*this, f, c);
}

XsdDateTimeResult::
~XsdDateTimeResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_type_factory_init (
  "XsdDateTimeResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_comparison_init;

bool
operator== (const XsdDateTimeResult& x, const XsdDateTimeResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdDateTimeResult& x, const XsdDateTimeResult& y)
{
  return !(x == y);
}

// XsdDoubleResult
//

XsdDoubleResult::
XsdDoubleResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdDoubleResult::
XsdDoubleResult (const ::XsdResult& _xsd_XsdResult_base,
                 const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDoubleResult::
XsdDoubleResult (const calculationID_type& calculationID,
                 const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdDoubleResult::
XsdDoubleResult (const XsdDoubleResult& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdDoubleResult::
XsdDoubleResult (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdDoubleResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdDoubleResult* XsdDoubleResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDoubleResult (*this, f, c);
}

XsdDoubleResult::
~XsdDoubleResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdDoubleResult >
_xsd_XsdDoubleResult_type_factory_init (
  "XsdDoubleResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdDoubleResult >
_xsd_XsdDoubleResult_comparison_init;

bool
operator== (const XsdDoubleResult& x, const XsdDoubleResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdDoubleResult& x, const XsdDoubleResult& y)
{
  return !(x == y);
}

// XsdErrorResult
//

XsdErrorResult::
XsdErrorResult ()
: ::XsdResult (),
  error_ (::xml_schema::flags (), this)
{
}

XsdErrorResult::
XsdErrorResult (const ::XsdResult& _xsd_XsdResult_base,
                const error_type& error)
: ::XsdResult (_xsd_XsdResult_base),
  error_ (error, ::xml_schema::flags (), this)
{
}

XsdErrorResult::
XsdErrorResult (const ::XsdResult& _xsd_XsdResult_base,
                ::std::auto_ptr< error_type >& error)
: ::XsdResult (_xsd_XsdResult_base),
  error_ (error, ::xml_schema::flags (), this)
{
}

XsdErrorResult::
XsdErrorResult (const calculationID_type& calculationID,
                const error_type& error)
: ::XsdResult (calculationID),
  error_ (error, ::xml_schema::flags (), this)
{
}

XsdErrorResult::
XsdErrorResult (const calculationID_type& calculationID,
                ::std::auto_ptr< error_type >& error)
: ::XsdResult (calculationID),
  error_ (error, ::xml_schema::flags (), this)
{
}

XsdErrorResult::
XsdErrorResult (const XsdErrorResult& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  error_ (x.error_, f, this)
{
}

XsdErrorResult::
XsdErrorResult (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  error_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdErrorResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // error
    //
    if (n.name () == "error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< error_type > r (
        error_traits::create (i, f, this));

      if (!error_.present ())
      {
        this->error_.set (r);
        continue;
      }
    }

    break;
  }

  if (!error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "error",
      "");
  }
}

XsdErrorResult* XsdErrorResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdErrorResult (*this, f, c);
}

XsdErrorResult::
~XsdErrorResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdErrorResult >
_xsd_XsdErrorResult_type_factory_init (
  "XsdErrorResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdErrorResult >
_xsd_XsdErrorResult_comparison_init;

bool
operator== (const XsdErrorResult& x, const XsdErrorResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.error () == y.error ()))
    return false;

  return true;
}

bool
operator!= (const XsdErrorResult& x, const XsdErrorResult& y)
{
  return !(x == y);
}

// XsdIntegerResult
//

XsdIntegerResult::
XsdIntegerResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdIntegerResult::
XsdIntegerResult (const ::XsdResult& _xsd_XsdResult_base,
                  const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdIntegerResult::
XsdIntegerResult (const calculationID_type& calculationID,
                  const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdIntegerResult::
XsdIntegerResult (const XsdIntegerResult& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdIntegerResult::
XsdIntegerResult (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdIntegerResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      if (!value_.present ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdIntegerResult* XsdIntegerResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdIntegerResult (*this, f, c);
}

XsdIntegerResult::
~XsdIntegerResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdIntegerResult >
_xsd_XsdIntegerResult_type_factory_init (
  "XsdIntegerResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdIntegerResult >
_xsd_XsdIntegerResult_comparison_init;

bool
operator== (const XsdIntegerResult& x, const XsdIntegerResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdIntegerResult& x, const XsdIntegerResult& y)
{
  return !(x == y);
}

// XsdStringResult
//

XsdStringResult::
XsdStringResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdStringResult::
XsdStringResult (const ::XsdResult& _xsd_XsdResult_base,
                 const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdStringResult::
XsdStringResult (const calculationID_type& calculationID,
                 const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdStringResult::
XsdStringResult (const XsdStringResult& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdStringResult::
XsdStringResult (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdStringResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdStringResult* XsdStringResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdStringResult (*this, f, c);
}

XsdStringResult::
~XsdStringResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdStringResult >
_xsd_XsdStringResult_type_factory_init (
  "XsdStringResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdStringResult >
_xsd_XsdStringResult_comparison_init;

bool
operator== (const XsdStringResult& x, const XsdStringResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdStringResult& x, const XsdStringResult& y)
{
  return !(x == y);
}

// XsdTenorResult
//

XsdTenorResult::
XsdTenorResult ()
: ::XsdResult (),
  value_ (::xml_schema::flags (), this)
{
}

XsdTenorResult::
XsdTenorResult (const ::XsdResult& _xsd_XsdResult_base,
                const value_type& value)
: ::XsdResult (_xsd_XsdResult_base),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdTenorResult::
XsdTenorResult (const calculationID_type& calculationID,
                const value_type& value)
: ::XsdResult (calculationID),
  value_ (value, ::xml_schema::flags (), this)
{
}

XsdTenorResult::
XsdTenorResult (const XsdTenorResult& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (x, f, c),
  value_ (x.value_, f, this)
{
}

XsdTenorResult::
XsdTenorResult (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void XsdTenorResult::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::XsdResult::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (r);
        continue;
      }
    }

    break;
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

XsdTenorResult* XsdTenorResult::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdTenorResult (*this, f, c);
}

XsdTenorResult::
~XsdTenorResult ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, XsdTenorResult >
_xsd_XsdTenorResult_type_factory_init (
  "XsdTenorResult",
  "");

static
const ::xsd::cxx::tree::comparison_initializer< 0, char, XsdTenorResult >
_xsd_XsdTenorResult_comparison_init;

bool
operator== (const XsdTenorResult& x, const XsdTenorResult& y)
{
  if (!(static_cast< const ::XsdResult& > (x) ==
        static_cast< const ::XsdResult& > (y)))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  return true;
}

bool
operator!= (const XsdTenorResult& x, const XsdTenorResult& y)
{
  return !(x == y);
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

::std::ostream&
operator<< (::std::ostream& o, const XsdResult& i)
{
  for (XsdResult::comment_const_iterator
       b (i.comment ().begin ()), e (i.comment ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "comment: " << *b;
  }

  o << ::std::endl << "calculationID: " << i.calculationID ();
  if (i.elapsedTime ())
  {
    o << ::std::endl << "elapsedTime: " << *i.elapsedTime ();
  }

  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdResult >
_xsd_XsdResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdBooleanResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdBooleanResult >
_xsd_XsdBooleanResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdDateResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdDateResult >
_xsd_XsdDateResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdDateTimeResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdDoubleResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdDoubleResult >
_xsd_XsdDoubleResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdErrorResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "error: " << i.error ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdErrorResult >
_xsd_XsdErrorResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdIntegerResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdIntegerResult >
_xsd_XsdIntegerResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdStringResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdStringResult >
_xsd_XsdStringResult_std_ostream_init;

::std::ostream&
operator<< (::std::ostream& o, const XsdTenorResult& i)
{
  o << static_cast< const ::XsdResult& > (i);

  o << ::std::endl << "value: " << i.value ();
  return o;
}

static
const ::xsd::cxx::tree::std_ostream_initializer< 0, char, XsdTenorResult >
_xsd_XsdTenorResult_std_ostream_init;

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (xercesc::DOMElement& e, const XsdResult& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // comment
  //
  for (XsdResult::comment_const_iterator
       b (i.comment ().begin ()), n (i.comment ().end ());
       b != n; ++b)
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "comment",
        e));

    s << *b;
  }

  // calculationID
  //
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "calculationID",
        e));

    a << i.calculationID ();
  }

  // elapsedTime
  //
  if (i.elapsedTime ())
  {
    xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elapsedTime",
        e));

    a << *i.elapsedTime ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdResult >
_xsd_XsdResult_type_serializer_init (
  "XsdResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdBooleanResult& i)
{
  e << static_cast< const ::XsdResult& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdBooleanResult >
_xsd_XsdBooleanResult_type_serializer_init (
  "XsdBooleanResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdDateResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdDateResult >
_xsd_XsdDateResult_type_serializer_init (
  "XsdDateResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdDateTimeResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_type_serializer_init (
  "XsdDateTimeResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdDoubleResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << ::xml_schema::as_double(i.value ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdDoubleResult >
_xsd_XsdDoubleResult_type_serializer_init (
  "XsdDoubleResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdErrorResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // error
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "error",
        e));

    s << i.error ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdErrorResult >
_xsd_XsdErrorResult_type_serializer_init (
  "XsdErrorResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdIntegerResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdIntegerResult >
_xsd_XsdIntegerResult_type_serializer_init (
  "XsdIntegerResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdStringResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdStringResult >
_xsd_XsdStringResult_type_serializer_init (
  "XsdStringResult",
  "");


void
operator<< (xercesc::DOMElement& e, const XsdTenorResult& i)
{
  e << static_cast< const ::XsdResult& > (i);

  // value
  //
  {
    xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, XsdTenorResult >
_xsd_XsdTenorResult_type_serializer_init (
  "XsdTenorResult",
  "");


#include <xsd/cxx/tree/stream-extraction-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::stream_extraction_plate< 0, boost::archive::binary_iarchive, char >
  stream_extraction_plate_init_0;
}

XsdResult::
XsdResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (s, f, c),
  comment_ (f, this),
  calculationID_ (f, this),
  elapsedTime_ (f, this)
{
  this->parse (s, f);
}

void XsdResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::size_t n;
    ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
    s >> as;
    if (n > 0)
    {
      comment_sequence& c (this->comment_);
      c.reserve (n);
      while (n--)
      {
        ::std::auto_ptr< comment_type > r (new comment_type (s, f, this));
        c.push_back (r);
      }
    }
  }

  {
    ::std::auto_ptr< calculationID_type > r (new calculationID_type (s, f, this));
    this->calculationID_.set (r);
  }

  {
    bool p;
    s >> p;
    if (p)
    {
      ::std::auto_ptr< elapsedTime_type > r (new elapsedTime_type (s, f, this));
      this->elapsedTime_.set (r);
    }
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdResult >
_xsd_XsdResult_stream_extraction_init_0 (
  "XsdResult",
  "");

XsdBooleanResult::
XsdBooleanResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (s, f, c)
{
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdBooleanResult >
_xsd_XsdBooleanResult_stream_extraction_init_0 (
  "XsdBooleanResult",
  "");

XsdDateResult::
XsdDateResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdDateResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::auto_ptr< value_type > r (new value_type (s, f, this));
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdDateResult >
_xsd_XsdDateResult_stream_extraction_init_0 (
  "XsdDateResult",
  "");

XsdDateTimeResult::
XsdDateTimeResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdDateTimeResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::auto_ptr< value_type > r (new value_type (s, f, this));
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_stream_extraction_init_0 (
  "XsdDateTimeResult",
  "");

XsdDoubleResult::
XsdDoubleResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdDoubleResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    value_type r;
    s >> r;
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdDoubleResult >
_xsd_XsdDoubleResult_stream_extraction_init_0 (
  "XsdDoubleResult",
  "");

XsdErrorResult::
XsdErrorResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  error_ (f, this)
{
  this->parse (s, f);
}

void XsdErrorResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::auto_ptr< error_type > r (new error_type (s, f, this));
    this->error_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdErrorResult >
_xsd_XsdErrorResult_stream_extraction_init_0 (
  "XsdErrorResult",
  "");

XsdIntegerResult::
XsdIntegerResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdIntegerResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    value_type r;
    s >> r;
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdIntegerResult >
_xsd_XsdIntegerResult_stream_extraction_init_0 (
  "XsdIntegerResult",
  "");

XsdStringResult::
XsdStringResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdStringResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::auto_ptr< value_type > r (new value_type (s, f, this));
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdStringResult >
_xsd_XsdStringResult_stream_extraction_init_0 (
  "XsdStringResult",
  "");

XsdTenorResult::
XsdTenorResult (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::XsdResult (s, f, c),
  value_ (f, this)
{
  this->parse (s, f);
}

void XsdTenorResult::
parse (::xml_schema::istream< boost::archive::binary_iarchive >& s,
       ::xml_schema::flags f)
{
  {
    ::std::auto_ptr< value_type > r (new value_type (s, f, this));
    this->value_.set (r);
  }
}

static
const ::xsd::cxx::tree::stream_extraction_initializer< 0, boost::archive::binary_iarchive, char, XsdTenorResult >
_xsd_XsdTenorResult_stream_extraction_init_0 (
  "XsdTenorResult",
  "");

#include <xsd/cxx/tree/stream-insertion-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::stream_insertion_plate< 0, boost::archive::binary_oarchive, char >
  stream_insertion_plate_init_0;
}

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdResult& x)
{
  {
    const XsdResult::comment_sequence& c (x.comment ());
    s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
    for (XsdResult::comment_const_iterator
         i (c.begin ()), e (c.end ());
         i != e; ++i)
    {
      s << *i;
    }
  }

  s << x.calculationID ();
  {
    bool p (x.elapsedTime ());
    s << p;
    if (p)
      s << *x.elapsedTime ();
  }

  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdResult >
_xsd_XsdResult_stream_insertion_init_0 (
  "XsdResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdBooleanResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdBooleanResult >
_xsd_XsdBooleanResult_stream_insertion_init_0 (
  "XsdBooleanResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDateResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdDateResult >
_xsd_XsdDateResult_stream_insertion_init_0 (
  "XsdDateResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDateTimeResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdDateTimeResult >
_xsd_XsdDateTimeResult_stream_insertion_init_0 (
  "XsdDateTimeResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdDoubleResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdDoubleResult >
_xsd_XsdDoubleResult_stream_insertion_init_0 (
  "XsdDoubleResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdErrorResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.error ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdErrorResult >
_xsd_XsdErrorResult_stream_insertion_init_0 (
  "XsdErrorResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdIntegerResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdIntegerResult >
_xsd_XsdIntegerResult_stream_insertion_init_0 (
  "XsdIntegerResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdStringResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdStringResult >
_xsd_XsdStringResult_stream_insertion_init_0 (
  "XsdStringResult",
  "");

::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >&
operator<< (::xsd::cxx::tree::ostream< boost::archive::binary_oarchive >& s,
            const XsdTenorResult& x)
{
  s << static_cast< const ::XsdResult& > (x);
  s << x.value ();
  return s;
}

static
const ::xsd::cxx::tree::stream_insertion_initializer< 0, boost::archive::binary_oarchive, char, XsdTenorResult >
_xsd_XsdTenorResult_stream_insertion_init_0 (
  "XsdTenorResult",
  "");

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

