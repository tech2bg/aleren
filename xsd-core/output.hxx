// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_CORE_OUTPUT_HXX
#define CXX___SCHEMA_XSD_CORE_OUTPUT_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdOutputDocument;
class XsdOutputError;
class XsdNodeError;
class XsdSchemaError;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "result.hxx"

#include "input.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "result.hxx"

#include "input.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdOutputDocument: public ::xml_schema::type
{
  public:
  // error
  // 
  typedef ::XsdOutputError error_type;
  typedef ::xsd::cxx::tree::optional< error_type > error_optional;
  typedef ::xsd::cxx::tree::traits< error_type, char > error_traits;

  const error_optional&
  error () const;

  error_optional&
  error ();

  void
  error (const error_type& x);

  void
  error (const error_optional& x);

  void
  error (::std::auto_ptr< error_type > p);

  // result
  // 
  typedef ::XsdResult result_type;
  typedef ::xsd::cxx::tree::sequence< result_type > result_sequence;
  typedef xsd::cxx::tree::sequence< result_type >::iterator result_iterator;
  typedef xsd::cxx::tree::sequence< result_type >::const_iterator result_const_iterator;
  typedef ::xsd::cxx::tree::traits< result_type, char > result_traits;

  const result_sequence&
  result () const;

  result_sequence&
  result ();

  void
  result (const result_sequence& s);

  // name
  // 
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // client
  // 
  typedef ::xml_schema::string client_type;
  typedef ::xsd::cxx::tree::optional< client_type > client_optional;
  typedef ::xsd::cxx::tree::traits< client_type, char > client_traits;

  const client_optional&
  client () const;

  client_optional&
  client ();

  void
  client (const client_type& x);

  void
  client (const client_optional& x);

  void
  client (::std::auto_ptr< client_type > p);

  // timeStamp
  // 
  typedef ::xml_schema::date_time timeStamp_type;
  typedef ::xsd::cxx::tree::optional< timeStamp_type > timeStamp_optional;
  typedef ::xsd::cxx::tree::traits< timeStamp_type, char > timeStamp_traits;

  const timeStamp_optional&
  timeStamp () const;

  timeStamp_optional&
  timeStamp ();

  void
  timeStamp (const timeStamp_type& x);

  void
  timeStamp (const timeStamp_optional& x);

  void
  timeStamp (::std::auto_ptr< timeStamp_type > p);

  // documentID
  // 
  typedef ::xml_schema::id documentID_type;
  typedef ::xsd::cxx::tree::traits< documentID_type, char > documentID_traits;

  const documentID_type&
  documentID () const;

  documentID_type&
  documentID ();

  void
  documentID (const documentID_type& x);

  void
  documentID (::std::auto_ptr< documentID_type > p);

  // Constructors.
  //
  XsdOutputDocument ();

  XsdOutputDocument (const documentID_type&);

  XsdOutputDocument (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdOutputDocument (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdOutputDocument (const XsdOutputDocument& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdOutputDocument*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdOutputDocument ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  error_optional error_;
  result_sequence result_;
  name_optional name_;
  client_optional client_;
  timeStamp_optional timeStamp_;
  ::xsd::cxx::tree::one< documentID_type > documentID_;
};

bool
operator== (const XsdOutputDocument&, const XsdOutputDocument&);

bool
operator!= (const XsdOutputDocument&, const XsdOutputDocument&);


class XsdOutputError: public ::xml_schema::type
{
  public:
  // parse
  // 
  typedef ::xml_schema::string parse_type;
  typedef ::xsd::cxx::tree::optional< parse_type > parse_optional;
  typedef ::xsd::cxx::tree::traits< parse_type, char > parse_traits;

  const parse_optional&
  parse () const;

  parse_optional&
  parse ();

  void
  parse (const parse_type& x);

  void
  parse (const parse_optional& x);

  void
  parse (::std::auto_ptr< parse_type > p);

  // validation
  // 
  typedef ::XsdSchemaError validation_type;
  typedef ::xsd::cxx::tree::optional< validation_type > validation_optional;
  typedef ::xsd::cxx::tree::traits< validation_type, char > validation_traits;

  const validation_optional&
  validation () const;

  validation_optional&
  validation ();

  void
  validation (const validation_type& x);

  void
  validation (const validation_optional& x);

  void
  validation (::std::auto_ptr< validation_type > p);

  // Constructors.
  //
  XsdOutputError ();

  XsdOutputError (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdOutputError (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdOutputError (const XsdOutputError& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdOutputError*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdOutputError ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  parse_optional parse_;
  validation_optional validation_;
};

bool
operator== (const XsdOutputError&, const XsdOutputError&);

bool
operator!= (const XsdOutputError&, const XsdOutputError&);


class XsdNodeError: public ::xml_schema::type
{
  public:
  // message
  // 
  typedef ::xml_schema::string message_type;
  typedef ::xsd::cxx::tree::sequence< message_type > message_sequence;
  typedef xsd::cxx::tree::sequence< message_type >::iterator message_iterator;
  typedef xsd::cxx::tree::sequence< message_type >::const_iterator message_const_iterator;
  typedef ::xsd::cxx::tree::traits< message_type, char > message_traits;

  const message_sequence&
  message () const;

  message_sequence&
  message ();

  void
  message (const message_sequence& s);

  // name
  // 
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // type
  // 
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  XsdNodeError ();

  XsdNodeError (const name_type&);

  XsdNodeError (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdNodeError (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdNodeError (const XsdNodeError& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual XsdNodeError*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdNodeError ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  message_sequence message_;
  ::xsd::cxx::tree::one< name_type > name_;
  type_optional type_;
};

bool
operator== (const XsdNodeError&, const XsdNodeError&);

bool
operator!= (const XsdNodeError&, const XsdNodeError&);


class XsdSchemaError: public ::XsdNodeError
{
  public:
  // uniqueID
  // 
  typedef ::xml_schema::id uniqueID_type;
  typedef ::xsd::cxx::tree::optional< uniqueID_type > uniqueID_optional;
  typedef ::xsd::cxx::tree::traits< uniqueID_type, char > uniqueID_traits;

  const uniqueID_optional&
  uniqueID () const;

  uniqueID_optional&
  uniqueID ();

  void
  uniqueID (const uniqueID_type& x);

  void
  uniqueID (const uniqueID_optional& x);

  void
  uniqueID (::std::auto_ptr< uniqueID_type > p);

  // index
  // 
  typedef ::xml_schema::unsigned_int index_type;
  typedef ::xsd::cxx::tree::traits< index_type, char > index_traits;

  const index_type&
  index () const;

  index_type&
  index ();

  void
  index (const index_type& x);

  // Constructors.
  //
  XsdSchemaError ();

  XsdSchemaError (const ::XsdNodeError&,
                  const index_type&);

  XsdSchemaError (const name_type&,
                  const index_type&);

  XsdSchemaError (::xml_schema::istream< boost::archive::binary_iarchive >& s,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdSchemaError (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdSchemaError (const XsdSchemaError& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdSchemaError*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdSchemaError ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< boost::archive::binary_iarchive >&,
         ::xml_schema::flags);

  uniqueID_optional uniqueID_;
  ::xsd::cxx::tree::one< index_type > index_;
};

bool
operator== (const XsdSchemaError&, const XsdSchemaError&);

bool
operator!= (const XsdSchemaError&, const XsdSchemaError&);


#ifndef XSD_DONT_INCLUDE_INLINE

#include "result.ixx"

#include "input.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const XsdOutputDocument&);

::std::ostream&
operator<< (::std::ostream&, const XsdOutputError&);

::std::ostream&
operator<< (::std::ostream&, const XsdNodeError&);

::std::ostream&
operator<< (::std::ostream&, const XsdSchemaError&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (const ::std::string& uri,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (const ::std::string& uri,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (const ::std::string& uri,
                   xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   const ::std::string& id,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   const ::std::string& id,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::std::istream& is,
                   const ::std::string& id,
                   xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (xercesc::InputSource& is,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (xercesc::InputSource& is,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (xercesc::InputSource& is,
                   xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (const xercesc::DOMDocument& d,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::XsdOutputDocument >
xsdOutputDocument (::xml_schema::dom::auto_ptr< xercesc::DOMDocument >& d,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdOutputDocument&);

// Serialize to std::ostream.
//

void
xsdOutputDocument (::std::ostream& os,
                   const ::XsdOutputDocument& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

void
xsdOutputDocument (::std::ostream& os,
                   const ::XsdOutputDocument& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

void
xsdOutputDocument (::std::ostream& os,
                   const ::XsdOutputDocument& x, 
                   xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
xsdOutputDocument (xercesc::XMLFormatTarget& ft,
                   const ::XsdOutputDocument& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

void
xsdOutputDocument (xercesc::XMLFormatTarget& ft,
                   const ::XsdOutputDocument& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

void
xsdOutputDocument (xercesc::XMLFormatTarget& ft,
                   const ::XsdOutputDocument& x, 
                   xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
xsdOutputDocument (xercesc::DOMDocument& d,
                   const ::XsdOutputDocument& x,
                   ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< xercesc::DOMDocument >
xsdOutputDocument (const ::XsdOutputDocument& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   ::xml_schema::flags f = 0);

void
operator<< (xercesc::DOMElement&, const XsdOutputError&);

void
operator<< (xercesc::DOMElement&, const XsdNodeError&);

void
operator<< (xercesc::DOMElement&, const XsdSchemaError&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdOutputDocument&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdOutputError&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdNodeError&);

::xml_schema::ostream< boost::archive::binary_oarchive >&
operator<< (::xml_schema::ostream< boost::archive::binary_oarchive >&,
            const XsdSchemaError&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "output.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_CORE_OUTPUT_HXX
