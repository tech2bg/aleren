// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_ROOT_IXX
#define CXX___SCHEMA_XSD_MATH_ROOT_IXX

// Begin prologue.
//
//
// End prologue.

#include "functional.ixx"

// XsdRootSolver
// 

inline
const XsdRootSolver::error_optional& XsdRootSolver::
error () const
{
  return this->error_;
}

inline
XsdRootSolver::error_optional& XsdRootSolver::
error ()
{
  return this->error_;
}

inline
void XsdRootSolver::
error (const error_type& x)
{
  this->error_.set (x);
}

inline
void XsdRootSolver::
error (const error_optional& x)
{
  this->error_ = x;
}

inline
void XsdRootSolver::
error (::std::auto_ptr< error_type > x)
{
  this->error_.set (x);
}

inline
const XsdRootSolver::maxIterations_optional& XsdRootSolver::
maxIterations () const
{
  return this->maxIterations_;
}

inline
XsdRootSolver::maxIterations_optional& XsdRootSolver::
maxIterations ()
{
  return this->maxIterations_;
}

inline
void XsdRootSolver::
maxIterations (const maxIterations_type& x)
{
  this->maxIterations_.set (x);
}

inline
void XsdRootSolver::
maxIterations (const maxIterations_optional& x)
{
  this->maxIterations_ = x;
}

inline
XsdRootSolver::maxIterations_type XsdRootSolver::
maxIterations_default_value ()
{
  return maxIterations_type (100ULL);
}


// XsdRootSolver1D
// 


// XsdMultiRootSolver
// 

inline
const XsdMultiRootSolver::type_optional& XsdMultiRootSolver::
type () const
{
  return this->type_;
}

inline
XsdMultiRootSolver::type_optional& XsdMultiRootSolver::
type ()
{
  return this->type_;
}

inline
void XsdMultiRootSolver::
type (const type_type& x)
{
  this->type_.set (x);
}

inline
void XsdMultiRootSolver::
type (const type_optional& x)
{
  this->type_ = x;
}

inline
void XsdMultiRootSolver::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

inline
const XsdMultiRootSolver::type_type& XsdMultiRootSolver::
type_default_value ()
{
  return type_default_value_;
}

inline
const XsdMultiRootSolver::gradient_optional& XsdMultiRootSolver::
gradient () const
{
  return this->gradient_;
}

inline
XsdMultiRootSolver::gradient_optional& XsdMultiRootSolver::
gradient ()
{
  return this->gradient_;
}

inline
void XsdMultiRootSolver::
gradient (const gradient_type& x)
{
  this->gradient_.set (x);
}

inline
void XsdMultiRootSolver::
gradient (const gradient_optional& x)
{
  this->gradient_ = x;
}

inline
XsdMultiRootSolver::gradient_type XsdMultiRootSolver::
gradient_default_value ()
{
  return gradient_type (false);
}

inline
const XsdMultiRootSolver::scaled_optional& XsdMultiRootSolver::
scaled () const
{
  return this->scaled_;
}

inline
XsdMultiRootSolver::scaled_optional& XsdMultiRootSolver::
scaled ()
{
  return this->scaled_;
}

inline
void XsdMultiRootSolver::
scaled (const scaled_type& x)
{
  this->scaled_.set (x);
}

inline
void XsdMultiRootSolver::
scaled (const scaled_optional& x)
{
  this->scaled_ = x;
}

inline
XsdMultiRootSolver::scaled_type XsdMultiRootSolver::
scaled_default_value ()
{
  return scaled_type (true);
}

inline
const XsdMultiRootSolver::modified_optional& XsdMultiRootSolver::
modified () const
{
  return this->modified_;
}

inline
XsdMultiRootSolver::modified_optional& XsdMultiRootSolver::
modified ()
{
  return this->modified_;
}

inline
void XsdMultiRootSolver::
modified (const modified_type& x)
{
  this->modified_.set (x);
}

inline
void XsdMultiRootSolver::
modified (const modified_optional& x)
{
  this->modified_ = x;
}

inline
XsdMultiRootSolver::modified_type XsdMultiRootSolver::
modified_default_value ()
{
  return modified_type (true);
}


// XsdValueRootSolver1D
// 

inline
const XsdValueRootSolver1D::type_optional& XsdValueRootSolver1D::
type () const
{
  return this->type_;
}

inline
XsdValueRootSolver1D::type_optional& XsdValueRootSolver1D::
type ()
{
  return this->type_;
}

inline
void XsdValueRootSolver1D::
type (const type_type& x)
{
  this->type_.set (x);
}

inline
void XsdValueRootSolver1D::
type (const type_optional& x)
{
  this->type_ = x;
}

inline
void XsdValueRootSolver1D::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

inline
const XsdValueRootSolver1D::type_type& XsdValueRootSolver1D::
type_default_value ()
{
  return type_default_value_;
}


// XsdGradientRootSolver1D
// 

inline
const XsdGradientRootSolver1D::type_optional& XsdGradientRootSolver1D::
type () const
{
  return this->type_;
}

inline
XsdGradientRootSolver1D::type_optional& XsdGradientRootSolver1D::
type ()
{
  return this->type_;
}

inline
void XsdGradientRootSolver1D::
type (const type_type& x)
{
  this->type_.set (x);
}

inline
void XsdGradientRootSolver1D::
type (const type_optional& x)
{
  this->type_ = x;
}

inline
void XsdGradientRootSolver1D::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

inline
const XsdGradientRootSolver1D::type_type& XsdGradientRootSolver1D::
type_default_value ()
{
  return type_default_value_;
}


// XsdRootSolverTest1D
// 

inline
const XsdRootSolverTest1D::result_optional& XsdRootSolverTest1D::
result () const
{
  return this->result_;
}

inline
XsdRootSolverTest1D::result_optional& XsdRootSolverTest1D::
result ()
{
  return this->result_;
}

inline
void XsdRootSolverTest1D::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdRootSolverTest1D::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdRootSolverTest1D::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdRootSolverTest1D::function_type& XsdRootSolverTest1D::
function () const
{
  return this->function_.get ();
}

inline
XsdRootSolverTest1D::function_type& XsdRootSolverTest1D::
function ()
{
  return this->function_.get ();
}

inline
void XsdRootSolverTest1D::
function (const function_type& x)
{
  this->function_.set (x);
}

inline
void XsdRootSolverTest1D::
function (::std::auto_ptr< function_type > x)
{
  this->function_.set (x);
}

inline
const XsdRootSolverTest1D::guess_optional& XsdRootSolverTest1D::
guess () const
{
  return this->guess_;
}

inline
XsdRootSolverTest1D::guess_optional& XsdRootSolverTest1D::
guess ()
{
  return this->guess_;
}

inline
void XsdRootSolverTest1D::
guess (const guess_type& x)
{
  this->guess_.set (x);
}

inline
void XsdRootSolverTest1D::
guess (const guess_optional& x)
{
  this->guess_ = x;
}

inline
XsdRootSolverTest1D::guess_type XsdRootSolverTest1D::
guess_default_value ()
{
  return guess_type (.0);
}

inline
const XsdRootSolverTest1D::bounds_type& XsdRootSolverTest1D::
bounds () const
{
  return this->bounds_.get ();
}

inline
XsdRootSolverTest1D::bounds_type& XsdRootSolverTest1D::
bounds ()
{
  return this->bounds_.get ();
}

inline
void XsdRootSolverTest1D::
bounds (const bounds_type& x)
{
  this->bounds_.set (x);
}

inline
void XsdRootSolverTest1D::
bounds (::std::auto_ptr< bounds_type > x)
{
  this->bounds_.set (x);
}

inline
const XsdRootSolverTest1D::solver_type& XsdRootSolverTest1D::
solver () const
{
  return this->solver_.get ();
}

inline
XsdRootSolverTest1D::solver_type& XsdRootSolverTest1D::
solver ()
{
  return this->solver_.get ();
}

inline
void XsdRootSolverTest1D::
solver (const solver_type& x)
{
  this->solver_.set (x);
}

inline
void XsdRootSolverTest1D::
solver (::std::auto_ptr< solver_type > x)
{
  this->solver_.set (x);
}


// XsdRootSolverTest
// 

inline
const XsdRootSolverTest::result_optional& XsdRootSolverTest::
result () const
{
  return this->result_;
}

inline
XsdRootSolverTest::result_optional& XsdRootSolverTest::
result ()
{
  return this->result_;
}

inline
void XsdRootSolverTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdRootSolverTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdRootSolverTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdRootSolverTest::function_sequence& XsdRootSolverTest::
function () const
{
  return this->function_;
}

inline
XsdRootSolverTest::function_sequence& XsdRootSolverTest::
function ()
{
  return this->function_;
}

inline
void XsdRootSolverTest::
function (const function_sequence& s)
{
  this->function_ = s;
}

inline
const XsdRootSolverTest::guess_type& XsdRootSolverTest::
guess () const
{
  return this->guess_.get ();
}

inline
XsdRootSolverTest::guess_type& XsdRootSolverTest::
guess ()
{
  return this->guess_.get ();
}

inline
void XsdRootSolverTest::
guess (const guess_type& x)
{
  this->guess_.set (x);
}

inline
void XsdRootSolverTest::
guess (::std::auto_ptr< guess_type > x)
{
  this->guess_.set (x);
}

inline
const XsdRootSolverTest::bounds_sequence& XsdRootSolverTest::
bounds () const
{
  return this->bounds_;
}

inline
XsdRootSolverTest::bounds_sequence& XsdRootSolverTest::
bounds ()
{
  return this->bounds_;
}

inline
void XsdRootSolverTest::
bounds (const bounds_sequence& s)
{
  this->bounds_ = s;
}

inline
const XsdRootSolverTest::solver_type& XsdRootSolverTest::
solver () const
{
  return this->solver_.get ();
}

inline
XsdRootSolverTest::solver_type& XsdRootSolverTest::
solver ()
{
  return this->solver_.get ();
}

inline
void XsdRootSolverTest::
solver (const solver_type& x)
{
  this->solver_.set (x);
}

inline
void XsdRootSolverTest::
solver (::std::auto_ptr< solver_type > x)
{
  this->solver_.set (x);
}


// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_ROOT_IXX
