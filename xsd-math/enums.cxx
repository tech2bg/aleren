// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "enums.hxx"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

// XsdAggregateType
//

XsdAggregateType::
XsdAggregateType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdAggregateType_convert ();
}

XsdAggregateType::
XsdAggregateType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdAggregateType_convert ();
}

XsdAggregateType::
XsdAggregateType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdAggregateType_convert ();
}

XsdAggregateType* XsdAggregateType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdAggregateType (*this, f, c);
}

XsdAggregateType::value XsdAggregateType::
_xsd_XsdAggregateType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdAggregateType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdAggregateType_indexes_,
                    _xsd_XsdAggregateType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdAggregateType_indexes_ + 4 || _xsd_XsdAggregateType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdAggregateType::
_xsd_XsdAggregateType_literals_[4] =
{
  "AVERAGE",
  "MAXIMUM",
  "MINIMUM",
  "TOTAL"
};

const XsdAggregateType::value XsdAggregateType::
_xsd_XsdAggregateType_indexes_[4] =
{
  ::XsdAggregateType::AVERAGE,
  ::XsdAggregateType::MAXIMUM,
  ::XsdAggregateType::MINIMUM,
  ::XsdAggregateType::TOTAL
};

// XsdAmericanAnalyticType
//

XsdAmericanAnalyticType::
XsdAmericanAnalyticType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdAmericanAnalyticType_convert ();
}

XsdAmericanAnalyticType::
XsdAmericanAnalyticType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdAmericanAnalyticType_convert ();
}

XsdAmericanAnalyticType::
XsdAmericanAnalyticType (const ::std::string& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdAmericanAnalyticType_convert ();
}

XsdAmericanAnalyticType* XsdAmericanAnalyticType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdAmericanAnalyticType (*this, f, c);
}

XsdAmericanAnalyticType::value XsdAmericanAnalyticType::
_xsd_XsdAmericanAnalyticType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdAmericanAnalyticType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdAmericanAnalyticType_indexes_,
                    _xsd_XsdAmericanAnalyticType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_XsdAmericanAnalyticType_indexes_ + 2 || _xsd_XsdAmericanAnalyticType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdAmericanAnalyticType::
_xsd_XsdAmericanAnalyticType_literals_[2] =
{
  "BARONE_ADESI_WHALEY",
  "BJERKSUND_STENSLAND"
};

const XsdAmericanAnalyticType::value XsdAmericanAnalyticType::
_xsd_XsdAmericanAnalyticType_indexes_[2] =
{
  ::XsdAmericanAnalyticType::BARONE_ADESI_WHALEY,
  ::XsdAmericanAnalyticType::BJERKSUND_STENSLAND
};

// XsdAverageType
//

XsdAverageType::
XsdAverageType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdAverageType_convert ();
}

XsdAverageType::
XsdAverageType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdAverageType_convert ();
}

XsdAverageType::
XsdAverageType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdAverageType_convert ();
}

XsdAverageType* XsdAverageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdAverageType (*this, f, c);
}

XsdAverageType::value XsdAverageType::
_xsd_XsdAverageType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdAverageType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdAverageType_indexes_,
                    _xsd_XsdAverageType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdAverageType_indexes_ + 4 || _xsd_XsdAverageType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdAverageType::
_xsd_XsdAverageType_literals_[4] =
{
  "ARITHMETIC",
  "GEOMETRIC",
  "HARMONIC",
  "MEDIAN"
};

const XsdAverageType::value XsdAverageType::
_xsd_XsdAverageType_indexes_[4] =
{
  ::XsdAverageType::ARITHMETIC,
  ::XsdAverageType::GEOMETRIC,
  ::XsdAverageType::HARMONIC,
  ::XsdAverageType::MEDIAN
};

// XsdBinomialType
//

XsdBinomialType::
XsdBinomialType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdBinomialType_convert ();
}

XsdBinomialType::
XsdBinomialType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdBinomialType_convert ();
}

XsdBinomialType::
XsdBinomialType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdBinomialType_convert ();
}

XsdBinomialType* XsdBinomialType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdBinomialType (*this, f, c);
}

XsdBinomialType::value XsdBinomialType::
_xsd_XsdBinomialType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdBinomialType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdBinomialType_indexes_,
                    _xsd_XsdBinomialType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_XsdBinomialType_indexes_ + 7 || _xsd_XsdBinomialType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdBinomialType::
_xsd_XsdBinomialType_literals_[7] =
{
  "ADDITIVE_EQP",
  "COX_ROSS_RUBINSTEIN",
  "JARROW_RUDD",
  "JOSHI4",
  "LEISEN_REIMER",
  "TIAN",
  "TRIGEORGIS"
};

const XsdBinomialType::value XsdBinomialType::
_xsd_XsdBinomialType_indexes_[7] =
{
  ::XsdBinomialType::ADDITIVE_EQP,
  ::XsdBinomialType::COX_ROSS_RUBINSTEIN,
  ::XsdBinomialType::JARROW_RUDD,
  ::XsdBinomialType::JOSHI4,
  ::XsdBinomialType::LEISEN_REIMER,
  ::XsdBinomialType::TIAN,
  ::XsdBinomialType::TRIGEORGIS
};

// XsdConjugateGradientType
//

XsdConjugateGradientType::
XsdConjugateGradientType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdConjugateGradientType_convert ();
}

XsdConjugateGradientType::
XsdConjugateGradientType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdConjugateGradientType_convert ();
}

XsdConjugateGradientType::
XsdConjugateGradientType (const ::std::string& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdConjugateGradientType_convert ();
}

XsdConjugateGradientType* XsdConjugateGradientType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdConjugateGradientType (*this, f, c);
}

XsdConjugateGradientType::value XsdConjugateGradientType::
_xsd_XsdConjugateGradientType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdConjugateGradientType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdConjugateGradientType_indexes_,
                    _xsd_XsdConjugateGradientType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdConjugateGradientType_indexes_ + 3 || _xsd_XsdConjugateGradientType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdConjugateGradientType::
_xsd_XsdConjugateGradientType_literals_[3] =
{
  "FLETCHER_REEVES",
  "POLAK_RIBIERE",
  "BROYDEN_FLETCHER_GOLDFARB_SHANNO"
};

const XsdConjugateGradientType::value XsdConjugateGradientType::
_xsd_XsdConjugateGradientType_indexes_[3] =
{
  ::XsdConjugateGradientType::BROYDEN_FLETCHER_GOLDFARB_SHANNO,
  ::XsdConjugateGradientType::FLETCHER_REEVES,
  ::XsdConjugateGradientType::POLAK_RIBIERE
};

// XsdCopulaType
//

XsdCopulaType::
XsdCopulaType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdCopulaType_convert ();
}

XsdCopulaType::
XsdCopulaType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdCopulaType_convert ();
}

XsdCopulaType::
XsdCopulaType (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdCopulaType_convert ();
}

XsdCopulaType* XsdCopulaType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdCopulaType (*this, f, c);
}

XsdCopulaType::value XsdCopulaType::
_xsd_XsdCopulaType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdCopulaType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdCopulaType_indexes_,
                    _xsd_XsdCopulaType_indexes_ + 12,
                    *this,
                    c));

  if (i == _xsd_XsdCopulaType_indexes_ + 12 || _xsd_XsdCopulaType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdCopulaType::
_xsd_XsdCopulaType_literals_[12] =
{
  "CLAYTON",
  "DEPENDENT",
  "DOUBLE_T",
  "FRANK",
  "GAUSSIAN",
  "GUMBEL",
  "INDEPENDENT",
  "MARSHALL_OLKIN",
  "MIXTURE",
  "NIGAUSSIAN",
  "STUDENT_T",
  "VGAMMA"
};

const XsdCopulaType::value XsdCopulaType::
_xsd_XsdCopulaType_indexes_[12] =
{
  ::XsdCopulaType::CLAYTON,
  ::XsdCopulaType::DEPENDENT,
  ::XsdCopulaType::DOUBLE_T,
  ::XsdCopulaType::FRANK,
  ::XsdCopulaType::GAUSSIAN,
  ::XsdCopulaType::GUMBEL,
  ::XsdCopulaType::INDEPENDENT,
  ::XsdCopulaType::MARSHALL_OLKIN,
  ::XsdCopulaType::MIXTURE,
  ::XsdCopulaType::NIGAUSSIAN,
  ::XsdCopulaType::STUDENT_T,
  ::XsdCopulaType::VGAMMA
};

// XsdCorrelationType
//

XsdCorrelationType::
XsdCorrelationType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdCorrelationType_convert ();
}

XsdCorrelationType::
XsdCorrelationType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdCorrelationType_convert ();
}

XsdCorrelationType::
XsdCorrelationType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdCorrelationType_convert ();
}

XsdCorrelationType* XsdCorrelationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdCorrelationType (*this, f, c);
}

XsdCorrelationType::value XsdCorrelationType::
_xsd_XsdCorrelationType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdCorrelationType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdCorrelationType_indexes_,
                    _xsd_XsdCorrelationType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdCorrelationType_indexes_ + 3 || _xsd_XsdCorrelationType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdCorrelationType::
_xsd_XsdCorrelationType_literals_[3] =
{
  "KENDALL",
  "PEARSON",
  "SPEARMAN"
};

const XsdCorrelationType::value XsdCorrelationType::
_xsd_XsdCorrelationType_indexes_[3] =
{
  ::XsdCorrelationType::KENDALL,
  ::XsdCorrelationType::PEARSON,
  ::XsdCorrelationType::SPEARMAN
};

// XsdCubicBoundaryType
//

XsdCubicBoundaryType::
XsdCubicBoundaryType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdCubicBoundaryType_convert ();
}

XsdCubicBoundaryType::
XsdCubicBoundaryType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdCubicBoundaryType_convert ();
}

XsdCubicBoundaryType::
XsdCubicBoundaryType (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdCubicBoundaryType_convert ();
}

XsdCubicBoundaryType* XsdCubicBoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdCubicBoundaryType (*this, f, c);
}

XsdCubicBoundaryType::value XsdCubicBoundaryType::
_xsd_XsdCubicBoundaryType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdCubicBoundaryType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdCubicBoundaryType_indexes_,
                    _xsd_XsdCubicBoundaryType_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_XsdCubicBoundaryType_indexes_ + 5 || _xsd_XsdCubicBoundaryType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdCubicBoundaryType::
_xsd_XsdCubicBoundaryType_literals_[5] =
{
  "DERIV_1ST",
  "DERIV_2ND",
  "NOT_A_KNOT",
  "PERIODIC",
  "LAGRANGE"
};

const XsdCubicBoundaryType::value XsdCubicBoundaryType::
_xsd_XsdCubicBoundaryType_indexes_[5] =
{
  ::XsdCubicBoundaryType::DERIV_1ST,
  ::XsdCubicBoundaryType::DERIV_2ND,
  ::XsdCubicBoundaryType::LAGRANGE,
  ::XsdCubicBoundaryType::NOT_A_KNOT,
  ::XsdCubicBoundaryType::PERIODIC
};

// XsdCubicDerivativeType
//

XsdCubicDerivativeType::
XsdCubicDerivativeType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdCubicDerivativeType_convert ();
}

XsdCubicDerivativeType::
XsdCubicDerivativeType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdCubicDerivativeType_convert ();
}

XsdCubicDerivativeType::
XsdCubicDerivativeType (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdCubicDerivativeType_convert ();
}

XsdCubicDerivativeType* XsdCubicDerivativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdCubicDerivativeType (*this, f, c);
}

XsdCubicDerivativeType::value XsdCubicDerivativeType::
_xsd_XsdCubicDerivativeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdCubicDerivativeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdCubicDerivativeType_indexes_,
                    _xsd_XsdCubicDerivativeType_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_XsdCubicDerivativeType_indexes_ + 8 || _xsd_XsdCubicDerivativeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdCubicDerivativeType::
_xsd_XsdCubicDerivativeType_literals_[8] =
{
  "AKIMA",
  "FOURTH_ORDER",
  "FRITSCH_BUTLAND",
  "KRUGER",
  "PARABOLIC",
  "SPLINE",
  "SPLINE_OM1",
  "SPLINE_OM2"
};

const XsdCubicDerivativeType::value XsdCubicDerivativeType::
_xsd_XsdCubicDerivativeType_indexes_[8] =
{
  ::XsdCubicDerivativeType::AKIMA,
  ::XsdCubicDerivativeType::FOURTH_ORDER,
  ::XsdCubicDerivativeType::FRITSCH_BUTLAND,
  ::XsdCubicDerivativeType::KRUGER,
  ::XsdCubicDerivativeType::PARABOLIC,
  ::XsdCubicDerivativeType::SPLINE,
  ::XsdCubicDerivativeType::SPLINE_OM1,
  ::XsdCubicDerivativeType::SPLINE_OM2
};

// XsdDifferenceType
//

XsdDifferenceType::
XsdDifferenceType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdDifferenceType_convert ();
}

XsdDifferenceType::
XsdDifferenceType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdDifferenceType_convert ();
}

XsdDifferenceType::
XsdDifferenceType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdDifferenceType_convert ();
}

XsdDifferenceType* XsdDifferenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDifferenceType (*this, f, c);
}

XsdDifferenceType::value XsdDifferenceType::
_xsd_XsdDifferenceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdDifferenceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdDifferenceType_indexes_,
                    _xsd_XsdDifferenceType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdDifferenceType_indexes_ + 3 || _xsd_XsdDifferenceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdDifferenceType::
_xsd_XsdDifferenceType_literals_[3] =
{
  "BACKWARD",
  "FORWARD",
  "CENTRAL"
};

const XsdDifferenceType::value XsdDifferenceType::
_xsd_XsdDifferenceType_indexes_[3] =
{
  ::XsdDifferenceType::BACKWARD,
  ::XsdDifferenceType::CENTRAL,
  ::XsdDifferenceType::FORWARD
};

// XsdDistributionType
//

XsdDistributionType::
XsdDistributionType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdDistributionType_convert ();
}

XsdDistributionType::
XsdDistributionType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdDistributionType_convert ();
}

XsdDistributionType::
XsdDistributionType (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdDistributionType_convert ();
}

XsdDistributionType* XsdDistributionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdDistributionType (*this, f, c);
}

XsdDistributionType::value XsdDistributionType::
_xsd_XsdDistributionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdDistributionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdDistributionType_indexes_,
                    _xsd_XsdDistributionType_indexes_ + 44,
                    *this,
                    c));

  if (i == _xsd_XsdDistributionType_indexes_ + 44 || _xsd_XsdDistributionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdDistributionType::
_xsd_XsdDistributionType_literals_[44] =
{
  "ASYMPTOTIC",
  "BERNOULLI",
  "BETA",
  "BINOMIAL",
  "CAUCHY",
  "CHI_SQUARE",
  "COMPOUND_POISSON",
  "CONDITIONAL",
  "CONVOLUTION",
  "COPULA",
  "COPULA_DISTRIBUTION",
  "EMPIRICAL",
  "EXPONENTIAL",
  "EXP_POWER",
  "EXTREME_VALUE",
  "FISHER_F",
  "GAMMA",
  "GENERALIZED_INVERSE_GAUSSIAN",
  "GENERIC",
  "GUMBEL",
  "INVERSE_CHI_SQUARE",
  "INVERSE_GAMMA",
  "INVERSE_GAUSSIAN",
  "LAPLACE",
  "LEVY_STABLE",
  "LHPA_GAUSSIAN",
  "LOGARITHMIC",
  "LOGISTIC",
  "LOGNORMAL",
  "MIXTURE",
  "NORMAL",
  "NORMAL_GAMMA",
  "NORMAL_INVERSE_GAUSSIAN",
  "PARETO",
  "POISSON",
  "RAYLEIGH",
  "SIMPLE",
  "SPECIAL",
  "STUDENT_T",
  "TRIANGULAR",
  "TRUNCATED",
  "UNIFORM",
  "VARIANCE_GAMMA",
  "WEIBULL"
};

const XsdDistributionType::value XsdDistributionType::
_xsd_XsdDistributionType_indexes_[44] =
{
  ::XsdDistributionType::ASYMPTOTIC,
  ::XsdDistributionType::BERNOULLI,
  ::XsdDistributionType::BETA,
  ::XsdDistributionType::BINOMIAL,
  ::XsdDistributionType::CAUCHY,
  ::XsdDistributionType::CHI_SQUARE,
  ::XsdDistributionType::COMPOUND_POISSON,
  ::XsdDistributionType::CONDITIONAL,
  ::XsdDistributionType::CONVOLUTION,
  ::XsdDistributionType::COPULA,
  ::XsdDistributionType::COPULA_DISTRIBUTION,
  ::XsdDistributionType::EMPIRICAL,
  ::XsdDistributionType::EXPONENTIAL,
  ::XsdDistributionType::EXP_POWER,
  ::XsdDistributionType::EXTREME_VALUE,
  ::XsdDistributionType::FISHER_F,
  ::XsdDistributionType::GAMMA,
  ::XsdDistributionType::GENERALIZED_INVERSE_GAUSSIAN,
  ::XsdDistributionType::GENERIC,
  ::XsdDistributionType::GUMBEL,
  ::XsdDistributionType::INVERSE_CHI_SQUARE,
  ::XsdDistributionType::INVERSE_GAMMA,
  ::XsdDistributionType::INVERSE_GAUSSIAN,
  ::XsdDistributionType::LAPLACE,
  ::XsdDistributionType::LEVY_STABLE,
  ::XsdDistributionType::LHPA_GAUSSIAN,
  ::XsdDistributionType::LOGARITHMIC,
  ::XsdDistributionType::LOGISTIC,
  ::XsdDistributionType::LOGNORMAL,
  ::XsdDistributionType::MIXTURE,
  ::XsdDistributionType::NORMAL,
  ::XsdDistributionType::NORMAL_GAMMA,
  ::XsdDistributionType::NORMAL_INVERSE_GAUSSIAN,
  ::XsdDistributionType::PARETO,
  ::XsdDistributionType::POISSON,
  ::XsdDistributionType::RAYLEIGH,
  ::XsdDistributionType::SIMPLE,
  ::XsdDistributionType::SPECIAL,
  ::XsdDistributionType::STUDENT_T,
  ::XsdDistributionType::TRIANGULAR,
  ::XsdDistributionType::TRUNCATED,
  ::XsdDistributionType::UNIFORM,
  ::XsdDistributionType::VARIANCE_GAMMA,
  ::XsdDistributionType::WEIBULL
};

// XsdEndpointType
//

XsdEndpointType::
XsdEndpointType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdEndpointType_convert ();
}

XsdEndpointType::
XsdEndpointType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdEndpointType_convert ();
}

XsdEndpointType::
XsdEndpointType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdEndpointType_convert ();
}

XsdEndpointType* XsdEndpointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdEndpointType (*this, f, c);
}

XsdEndpointType::value XsdEndpointType::
_xsd_XsdEndpointType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdEndpointType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdEndpointType_indexes_,
                    _xsd_XsdEndpointType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdEndpointType_indexes_ + 4 || _xsd_XsdEndpointType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdEndpointType::
_xsd_XsdEndpointType_literals_[4] =
{
  "BOTH",
  "LEFT",
  "NONE",
  "RIGHT"
};

const XsdEndpointType::value XsdEndpointType::
_xsd_XsdEndpointType_indexes_[4] =
{
  ::XsdEndpointType::BOTH,
  ::XsdEndpointType::LEFT,
  ::XsdEndpointType::NONE,
  ::XsdEndpointType::RIGHT
};

// XsdErrorType
//

XsdErrorType::
XsdErrorType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdErrorType_convert ();
}

XsdErrorType::
XsdErrorType (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdErrorType_convert ();
}

XsdErrorType::
XsdErrorType (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdErrorType_convert ();
}

XsdErrorType* XsdErrorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdErrorType (*this, f, c);
}

XsdErrorType::value XsdErrorType::
_xsd_XsdErrorType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdErrorType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdErrorType_indexes_,
                    _xsd_XsdErrorType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdErrorType_indexes_ + 4 || _xsd_XsdErrorType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdErrorType::
_xsd_XsdErrorType_literals_[4] =
{
  "ABSOLUTE_PRICE",
  "IMPLIED_VOLATILITY",
  "RELATIVE_PRICE",
  "UNKNOWN"
};

const XsdErrorType::value XsdErrorType::
_xsd_XsdErrorType_indexes_[4] =
{
  ::XsdErrorType::ABSOLUTE_PRICE,
  ::XsdErrorType::IMPLIED_VOLATILITY,
  ::XsdErrorType::RELATIVE_PRICE,
  ::XsdErrorType::UNKNOWN
};

// XsdEvolveType
//

XsdEvolveType::
XsdEvolveType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdEvolveType_convert ();
}

XsdEvolveType::
XsdEvolveType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdEvolveType_convert ();
}

XsdEvolveType::
XsdEvolveType (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdEvolveType_convert ();
}

XsdEvolveType* XsdEvolveType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdEvolveType (*this, f, c);
}

XsdEvolveType::value XsdEvolveType::
_xsd_XsdEvolveType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdEvolveType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdEvolveType_indexes_,
                    _xsd_XsdEvolveType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdEvolveType_indexes_ + 4 || _xsd_XsdEvolveType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdEvolveType::
_xsd_XsdEvolveType_literals_[4] =
{
  "EULER",
  "EULER_END",
  "MILSTEIN",
  "PREDICTOR_CORRECTOR"
};

const XsdEvolveType::value XsdEvolveType::
_xsd_XsdEvolveType_indexes_[4] =
{
  ::XsdEvolveType::EULER,
  ::XsdEvolveType::EULER_END,
  ::XsdEvolveType::MILSTEIN,
  ::XsdEvolveType::PREDICTOR_CORRECTOR
};

// XsdExtrapolate
//

XsdExtrapolate::
XsdExtrapolate (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdExtrapolate_convert ();
}

XsdExtrapolate::
XsdExtrapolate (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdExtrapolate_convert ();
}

XsdExtrapolate::
XsdExtrapolate (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdExtrapolate_convert ();
}

XsdExtrapolate* XsdExtrapolate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdExtrapolate (*this, f, c);
}

XsdExtrapolate::value XsdExtrapolate::
_xsd_XsdExtrapolate_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdExtrapolate_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdExtrapolate_indexes_,
                    _xsd_XsdExtrapolate_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdExtrapolate_indexes_ + 4 || _xsd_XsdExtrapolate_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdExtrapolate::
_xsd_XsdExtrapolate_literals_[4] =
{
  "CONSTANT",
  "LINEAR",
  "NONE",
  "ZERO"
};

const XsdExtrapolate::value XsdExtrapolate::
_xsd_XsdExtrapolate_indexes_[4] =
{
  ::XsdExtrapolate::CONSTANT,
  ::XsdExtrapolate::LINEAR,
  ::XsdExtrapolate::NONE,
  ::XsdExtrapolate::ZERO
};

// XsdFdmScheme
//

XsdFdmScheme::
XsdFdmScheme (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdFdmScheme_convert ();
}

XsdFdmScheme::
XsdFdmScheme (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdFdmScheme_convert ();
}

XsdFdmScheme::
XsdFdmScheme (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdFdmScheme_convert ();
}

XsdFdmScheme* XsdFdmScheme::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdFdmScheme (*this, f, c);
}

XsdFdmScheme::value XsdFdmScheme::
_xsd_XsdFdmScheme_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdFdmScheme_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdFdmScheme_indexes_,
                    _xsd_XsdFdmScheme_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_XsdFdmScheme_indexes_ + 6 || _xsd_XsdFdmScheme_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdFdmScheme::
_xsd_XsdFdmScheme_literals_[6] =
{
  "CRAIG_SNEYD",
  "CRAIG_SNEYD_MODIFIED",
  "DOUGLAS",
  "EULER_EXPLICIT",
  "EULER_IMPLICIT",
  "HUNDSDORFER"
};

const XsdFdmScheme::value XsdFdmScheme::
_xsd_XsdFdmScheme_indexes_[6] =
{
  ::XsdFdmScheme::CRAIG_SNEYD,
  ::XsdFdmScheme::CRAIG_SNEYD_MODIFIED,
  ::XsdFdmScheme::DOUGLAS,
  ::XsdFdmScheme::EULER_EXPLICIT,
  ::XsdFdmScheme::EULER_IMPLICIT,
  ::XsdFdmScheme::HUNDSDORFER
};

// XsdGammaRngType
//

XsdGammaRngType::
XsdGammaRngType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdGammaRngType_convert ();
}

XsdGammaRngType::
XsdGammaRngType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdGammaRngType_convert ();
}

XsdGammaRngType::
XsdGammaRngType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdGammaRngType_convert ();
}

XsdGammaRngType* XsdGammaRngType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdGammaRngType (*this, f, c);
}

XsdGammaRngType::value XsdGammaRngType::
_xsd_XsdGammaRngType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdGammaRngType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdGammaRngType_indexes_,
                    _xsd_XsdGammaRngType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdGammaRngType_indexes_ + 3 || _xsd_XsdGammaRngType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdGammaRngType::
_xsd_XsdGammaRngType_literals_[3] =
{
  "DEFAULT",
  "KNUTH",
  "MARSAGLIA_TSANG"
};

const XsdGammaRngType::value XsdGammaRngType::
_xsd_XsdGammaRngType_indexes_[3] =
{
  ::XsdGammaRngType::DEFAULT,
  ::XsdGammaRngType::KNUTH,
  ::XsdGammaRngType::MARSAGLIA_TSANG
};

// XsdGradientRoot1DType
//

XsdGradientRoot1DType::
XsdGradientRoot1DType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdGradientRoot1DType_convert ();
}

XsdGradientRoot1DType::
XsdGradientRoot1DType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdGradientRoot1DType_convert ();
}

XsdGradientRoot1DType::
XsdGradientRoot1DType (const ::std::string& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdGradientRoot1DType_convert ();
}

XsdGradientRoot1DType* XsdGradientRoot1DType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdGradientRoot1DType (*this, f, c);
}

XsdGradientRoot1DType::value XsdGradientRoot1DType::
_xsd_XsdGradientRoot1DType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdGradientRoot1DType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdGradientRoot1DType_indexes_,
                    _xsd_XsdGradientRoot1DType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdGradientRoot1DType_indexes_ + 3 || _xsd_XsdGradientRoot1DType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdGradientRoot1DType::
_xsd_XsdGradientRoot1DType_literals_[3] =
{
  "NEWTON",
  "SECANT",
  "STEFFENSON"
};

const XsdGradientRoot1DType::value XsdGradientRoot1DType::
_xsd_XsdGradientRoot1DType_indexes_[3] =
{
  ::XsdGradientRoot1DType::NEWTON,
  ::XsdGradientRoot1DType::SECANT,
  ::XsdGradientRoot1DType::STEFFENSON
};

// XsdMomentType
//

XsdMomentType::
XsdMomentType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMomentType_convert ();
}

XsdMomentType::
XsdMomentType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMomentType_convert ();
}

XsdMomentType::
XsdMomentType (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMomentType_convert ();
}

XsdMomentType* XsdMomentType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMomentType (*this, f, c);
}

XsdMomentType::value XsdMomentType::
_xsd_XsdMomentType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMomentType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMomentType_indexes_,
                    _xsd_XsdMomentType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdMomentType_indexes_ + 4 || _xsd_XsdMomentType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMomentType::
_xsd_XsdMomentType_literals_[4] =
{
  "MEAN",
  "VARIANCE",
  "SKEWNESS",
  "KURTOSIS"
};

const XsdMomentType::value XsdMomentType::
_xsd_XsdMomentType_indexes_[4] =
{
  ::XsdMomentType::KURTOSIS,
  ::XsdMomentType::MEAN,
  ::XsdMomentType::SKEWNESS,
  ::XsdMomentType::VARIANCE
};

// XsdPdeTimeScheme
//

XsdPdeTimeScheme::
XsdPdeTimeScheme (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdPdeTimeScheme_convert ();
}

XsdPdeTimeScheme::
XsdPdeTimeScheme (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdPdeTimeScheme_convert ();
}

XsdPdeTimeScheme::
XsdPdeTimeScheme (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdPdeTimeScheme_convert ();
}

XsdPdeTimeScheme* XsdPdeTimeScheme::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdPdeTimeScheme (*this, f, c);
}

XsdPdeTimeScheme::value XsdPdeTimeScheme::
_xsd_XsdPdeTimeScheme_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdPdeTimeScheme_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdPdeTimeScheme_indexes_,
                    _xsd_XsdPdeTimeScheme_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdPdeTimeScheme_indexes_ + 3 || _xsd_XsdPdeTimeScheme_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdPdeTimeScheme::
_xsd_XsdPdeTimeScheme_literals_[3] =
{
  "CRANK_NICOLSON",
  "EXPLICIT_EULER",
  "IMPLICIT_EULER"
};

const XsdPdeTimeScheme::value XsdPdeTimeScheme::
_xsd_XsdPdeTimeScheme_indexes_[3] =
{
  ::XsdPdeTimeScheme::CRANK_NICOLSON,
  ::XsdPdeTimeScheme::EXPLICIT_EULER,
  ::XsdPdeTimeScheme::IMPLICIT_EULER
};

// XsdGaussKronrodRule
//

XsdGaussKronrodRule::
XsdGaussKronrodRule (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdGaussKronrodRule_convert ();
}

XsdGaussKronrodRule::
XsdGaussKronrodRule (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdGaussKronrodRule_convert ();
}

XsdGaussKronrodRule::
XsdGaussKronrodRule (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdGaussKronrodRule_convert ();
}

XsdGaussKronrodRule* XsdGaussKronrodRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdGaussKronrodRule (*this, f, c);
}

XsdGaussKronrodRule::value XsdGaussKronrodRule::
_xsd_XsdGaussKronrodRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdGaussKronrodRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdGaussKronrodRule_indexes_,
                    _xsd_XsdGaussKronrodRule_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_XsdGaussKronrodRule_indexes_ + 6 || _xsd_XsdGaussKronrodRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdGaussKronrodRule::
_xsd_XsdGaussKronrodRule_literals_[6] =
{
  "GK15",
  "GK21",
  "GK31",
  "GK41",
  "GK51",
  "GK61"
};

const XsdGaussKronrodRule::value XsdGaussKronrodRule::
_xsd_XsdGaussKronrodRule_indexes_[6] =
{
  ::XsdGaussKronrodRule::GK15,
  ::XsdGaussKronrodRule::GK21,
  ::XsdGaussKronrodRule::GK31,
  ::XsdGaussKronrodRule::GK41,
  ::XsdGaussKronrodRule::GK51,
  ::XsdGaussKronrodRule::GK61
};

// XsdMinLinearBasis
//

XsdMinLinearBasis::
XsdMinLinearBasis (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMinLinearBasis_convert ();
}

XsdMinLinearBasis::
XsdMinLinearBasis (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMinLinearBasis_convert ();
}

XsdMinLinearBasis::
XsdMinLinearBasis (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMinLinearBasis_convert ();
}

XsdMinLinearBasis* XsdMinLinearBasis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMinLinearBasis (*this, f, c);
}

XsdMinLinearBasis::value XsdMinLinearBasis::
_xsd_XsdMinLinearBasis_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMinLinearBasis_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMinLinearBasis_indexes_,
                    _xsd_XsdMinLinearBasis_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdMinLinearBasis_indexes_ + 3 || _xsd_XsdMinLinearBasis_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMinLinearBasis::
_xsd_XsdMinLinearBasis_literals_[3] =
{
  "ADVANCED",
  "BIXBY",
  "STANDARD"
};

const XsdMinLinearBasis::value XsdMinLinearBasis::
_xsd_XsdMinLinearBasis_indexes_[3] =
{
  ::XsdMinLinearBasis::ADVANCED,
  ::XsdMinLinearBasis::BIXBY,
  ::XsdMinLinearBasis::STANDARD
};

// XsdMinLinearMethod
//

XsdMinLinearMethod::
XsdMinLinearMethod (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMinLinearMethod_convert ();
}

XsdMinLinearMethod::
XsdMinLinearMethod (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMinLinearMethod_convert ();
}

XsdMinLinearMethod::
XsdMinLinearMethod (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMinLinearMethod_convert ();
}

XsdMinLinearMethod* XsdMinLinearMethod::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMinLinearMethod (*this, f, c);
}

XsdMinLinearMethod::value XsdMinLinearMethod::
_xsd_XsdMinLinearMethod_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMinLinearMethod_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMinLinearMethod_indexes_,
                    _xsd_XsdMinLinearMethod_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_XsdMinLinearMethod_indexes_ + 2 || _xsd_XsdMinLinearMethod_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMinLinearMethod::
_xsd_XsdMinLinearMethod_literals_[2] =
{
  "INTERIOR",
  "SIMPLEX"
};

const XsdMinLinearMethod::value XsdMinLinearMethod::
_xsd_XsdMinLinearMethod_indexes_[2] =
{
  ::XsdMinLinearMethod::INTERIOR,
  ::XsdMinLinearMethod::SIMPLEX
};

// XsdMinLinearScale
//

XsdMinLinearScale::
XsdMinLinearScale (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMinLinearScale_convert ();
}

XsdMinLinearScale::
XsdMinLinearScale (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMinLinearScale_convert ();
}

XsdMinLinearScale::
XsdMinLinearScale (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMinLinearScale_convert ();
}

XsdMinLinearScale* XsdMinLinearScale::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMinLinearScale (*this, f, c);
}

XsdMinLinearScale::value XsdMinLinearScale::
_xsd_XsdMinLinearScale_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMinLinearScale_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMinLinearScale_indexes_,
                    _xsd_XsdMinLinearScale_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdMinLinearScale_indexes_ + 4 || _xsd_XsdMinLinearScale_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMinLinearScale::
_xsd_XsdMinLinearScale_literals_[4] =
{
  "AUTOMATIC",
  "EQUILIBRATION",
  "GEOMETRIC_MEAN",
  "NONE"
};

const XsdMinLinearScale::value XsdMinLinearScale::
_xsd_XsdMinLinearScale_indexes_[4] =
{
  ::XsdMinLinearScale::AUTOMATIC,
  ::XsdMinLinearScale::EQUILIBRATION,
  ::XsdMinLinearScale::GEOMETRIC_MEAN,
  ::XsdMinLinearScale::NONE
};

// XsdMonteCarloRule
//

XsdMonteCarloRule::
XsdMonteCarloRule (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMonteCarloRule_convert ();
}

XsdMonteCarloRule::
XsdMonteCarloRule (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMonteCarloRule_convert ();
}

XsdMonteCarloRule::
XsdMonteCarloRule (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMonteCarloRule_convert ();
}

XsdMonteCarloRule* XsdMonteCarloRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMonteCarloRule (*this, f, c);
}

XsdMonteCarloRule::value XsdMonteCarloRule::
_xsd_XsdMonteCarloRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMonteCarloRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMonteCarloRule_indexes_,
                    _xsd_XsdMonteCarloRule_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdMonteCarloRule_indexes_ + 3 || _xsd_XsdMonteCarloRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMonteCarloRule::
_xsd_XsdMonteCarloRule_literals_[3] =
{
  "PLAIN",
  "MISER",
  "VEGAS"
};

const XsdMonteCarloRule::value XsdMonteCarloRule::
_xsd_XsdMonteCarloRule_indexes_[3] =
{
  ::XsdMonteCarloRule::MISER,
  ::XsdMonteCarloRule::PLAIN,
  ::XsdMonteCarloRule::VEGAS
};

// XsdMultiRootType
//

XsdMultiRootType::
XsdMultiRootType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdMultiRootType_convert ();
}

XsdMultiRootType::
XsdMultiRootType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdMultiRootType_convert ();
}

XsdMultiRootType::
XsdMultiRootType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdMultiRootType_convert ();
}

XsdMultiRootType* XsdMultiRootType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdMultiRootType (*this, f, c);
}

XsdMultiRootType::value XsdMultiRootType::
_xsd_XsdMultiRootType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdMultiRootType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdMultiRootType_indexes_,
                    _xsd_XsdMultiRootType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdMultiRootType_indexes_ + 3 || _xsd_XsdMultiRootType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdMultiRootType::
_xsd_XsdMultiRootType_literals_[3] =
{
  "BROYDEN",
  "HYBRID",
  "NEWTON"
};

const XsdMultiRootType::value XsdMultiRootType::
_xsd_XsdMultiRootType_indexes_[3] =
{
  ::XsdMultiRootType::BROYDEN,
  ::XsdMultiRootType::HYBRID,
  ::XsdMultiRootType::NEWTON
};

// XsdNormalRngType
//

XsdNormalRngType::
XsdNormalRngType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdNormalRngType_convert ();
}

XsdNormalRngType::
XsdNormalRngType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdNormalRngType_convert ();
}

XsdNormalRngType::
XsdNormalRngType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdNormalRngType_convert ();
}

XsdNormalRngType* XsdNormalRngType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdNormalRngType (*this, f, c);
}

XsdNormalRngType::value XsdNormalRngType::
_xsd_XsdNormalRngType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdNormalRngType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdNormalRngType_indexes_,
                    _xsd_XsdNormalRngType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdNormalRngType_indexes_ + 4 || _xsd_XsdNormalRngType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdNormalRngType::
_xsd_XsdNormalRngType_literals_[4] =
{
  "BOX_MULLER",
  "DEFAULT",
  "RATIO",
  "ZIGGURAT"
};

const XsdNormalRngType::value XsdNormalRngType::
_xsd_XsdNormalRngType_indexes_[4] =
{
  ::XsdNormalRngType::BOX_MULLER,
  ::XsdNormalRngType::DEFAULT,
  ::XsdNormalRngType::RATIO,
  ::XsdNormalRngType::ZIGGURAT
};

// XsdOdeSolverType
//

XsdOdeSolverType::
XsdOdeSolverType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdOdeSolverType_convert ();
}

XsdOdeSolverType::
XsdOdeSolverType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdOdeSolverType_convert ();
}

XsdOdeSolverType::
XsdOdeSolverType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdOdeSolverType_convert ();
}

XsdOdeSolverType* XsdOdeSolverType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdOdeSolverType (*this, f, c);
}

XsdOdeSolverType::value XsdOdeSolverType::
_xsd_XsdOdeSolverType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdOdeSolverType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdOdeSolverType_indexes_,
                    _xsd_XsdOdeSolverType_indexes_ + 11,
                    *this,
                    c));

  if (i == _xsd_XsdOdeSolverType_indexes_ + 11 || _xsd_XsdOdeSolverType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdOdeSolverType::
_xsd_XsdOdeSolverType_literals_[11] =
{
  "BSIMP",
  "GEAR1",
  "GEAR2",
  "RK2",
  "RK2IMP",
  "RK2SIMP",
  "RK4",
  "RK4IMP",
  "RK8PD",
  "RKCK",
  "RKF45"
};

const XsdOdeSolverType::value XsdOdeSolverType::
_xsd_XsdOdeSolverType_indexes_[11] =
{
  ::XsdOdeSolverType::BSIMP,
  ::XsdOdeSolverType::GEAR1,
  ::XsdOdeSolverType::GEAR2,
  ::XsdOdeSolverType::RK2,
  ::XsdOdeSolverType::RK2IMP,
  ::XsdOdeSolverType::RK2SIMP,
  ::XsdOdeSolverType::RK4,
  ::XsdOdeSolverType::RK4IMP,
  ::XsdOdeSolverType::RK8PD,
  ::XsdOdeSolverType::RKCK,
  ::XsdOdeSolverType::RKF45
};

// XsdPathScheme
//

XsdPathScheme::
XsdPathScheme (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdPathScheme_convert ();
}

XsdPathScheme::
XsdPathScheme (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdPathScheme_convert ();
}

XsdPathScheme::
XsdPathScheme (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdPathScheme_convert ();
}

XsdPathScheme* XsdPathScheme::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdPathScheme (*this, f, c);
}

XsdPathScheme::value XsdPathScheme::
_xsd_XsdPathScheme_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdPathScheme_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdPathScheme_indexes_,
                    _xsd_XsdPathScheme_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_XsdPathScheme_indexes_ + 2 || _xsd_XsdPathScheme_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdPathScheme::
_xsd_XsdPathScheme_literals_[2] =
{
  "EULER",
  "MILSTEIN"
};

const XsdPathScheme::value XsdPathScheme::
_xsd_XsdPathScheme_indexes_[2] =
{
  ::XsdPathScheme::EULER,
  ::XsdPathScheme::MILSTEIN
};

// XsdRandomType
//

XsdRandomType::
XsdRandomType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdRandomType_convert ();
}

XsdRandomType::
XsdRandomType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdRandomType_convert ();
}

XsdRandomType::
XsdRandomType (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdRandomType_convert ();
}

XsdRandomType* XsdRandomType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdRandomType (*this, f, c);
}

XsdRandomType::value XsdRandomType::
_xsd_XsdRandomType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdRandomType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdRandomType_indexes_,
                    _xsd_XsdRandomType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_XsdRandomType_indexes_ + 2 || _xsd_XsdRandomType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdRandomType::
_xsd_XsdRandomType_literals_[2] =
{
  "PSEUDO",
  "QUASI"
};

const XsdRandomType::value XsdRandomType::
_xsd_XsdRandomType_indexes_[2] =
{
  ::XsdRandomType::PSEUDO,
  ::XsdRandomType::QUASI
};

// XsdSalvageType
//

XsdSalvageType::
XsdSalvageType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdSalvageType_convert ();
}

XsdSalvageType::
XsdSalvageType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdSalvageType_convert ();
}

XsdSalvageType::
XsdSalvageType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdSalvageType_convert ();
}

XsdSalvageType* XsdSalvageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSalvageType (*this, f, c);
}

XsdSalvageType::value XsdSalvageType::
_xsd_XsdSalvageType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdSalvageType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdSalvageType_indexes_,
                    _xsd_XsdSalvageType_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_XsdSalvageType_indexes_ + 5 || _xsd_XsdSalvageType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdSalvageType::
_xsd_XsdSalvageType_literals_[5] =
{
  "NONE",
  "SPECTRAL",
  "HYPERSPHERE",
  "LOWER_DIAGONAL",
  "HIGHAM"
};

const XsdSalvageType::value XsdSalvageType::
_xsd_XsdSalvageType_indexes_[5] =
{
  ::XsdSalvageType::HIGHAM,
  ::XsdSalvageType::HYPERSPHERE,
  ::XsdSalvageType::LOWER_DIAGONAL,
  ::XsdSalvageType::NONE,
  ::XsdSalvageType::SPECTRAL
};

// XsdRoundType
//

XsdRoundType::
XsdRoundType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdRoundType_convert ();
}

XsdRoundType::
XsdRoundType (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdRoundType_convert ();
}

XsdRoundType::
XsdRoundType (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdRoundType_convert ();
}

XsdRoundType* XsdRoundType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdRoundType (*this, f, c);
}

XsdRoundType::value XsdRoundType::
_xsd_XsdRoundType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdRoundType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdRoundType_indexes_,
                    _xsd_XsdRoundType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdRoundType_indexes_ + 3 || _xsd_XsdRoundType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdRoundType::
_xsd_XsdRoundType_literals_[3] =
{
  "DOWN",
  "NEAREST",
  "UP"
};

const XsdRoundType::value XsdRoundType::
_xsd_XsdRoundType_indexes_[3] =
{
  ::XsdRoundType::DOWN,
  ::XsdRoundType::NEAREST,
  ::XsdRoundType::UP
};

// XsdSingularValueType
//

XsdSingularValueType::
XsdSingularValueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdSingularValueType_convert ();
}

XsdSingularValueType::
XsdSingularValueType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdSingularValueType_convert ();
}

XsdSingularValueType::
XsdSingularValueType (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdSingularValueType_convert ();
}

XsdSingularValueType* XsdSingularValueType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSingularValueType (*this, f, c);
}

XsdSingularValueType::value XsdSingularValueType::
_xsd_XsdSingularValueType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdSingularValueType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdSingularValueType_indexes_,
                    _xsd_XsdSingularValueType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdSingularValueType_indexes_ + 3 || _xsd_XsdSingularValueType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdSingularValueType::
_xsd_XsdSingularValueType_literals_[3] =
{
  "DEFAULT",
  "JACOBI",
  "MODIFIED"
};

const XsdSingularValueType::value XsdSingularValueType::
_xsd_XsdSingularValueType_indexes_[3] =
{
  ::XsdSingularValueType::DEFAULT,
  ::XsdSingularValueType::JACOBI,
  ::XsdSingularValueType::MODIFIED
};

// XsdSobolDirectionIntegers
//

XsdSobolDirectionIntegers::
XsdSobolDirectionIntegers (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdSobolDirectionIntegers_convert ();
}

XsdSobolDirectionIntegers::
XsdSobolDirectionIntegers (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdSobolDirectionIntegers_convert ();
}

XsdSobolDirectionIntegers::
XsdSobolDirectionIntegers (const ::std::string& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdSobolDirectionIntegers_convert ();
}

XsdSobolDirectionIntegers* XsdSobolDirectionIntegers::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSobolDirectionIntegers (*this, f, c);
}

XsdSobolDirectionIntegers::value XsdSobolDirectionIntegers::
_xsd_XsdSobolDirectionIntegers_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdSobolDirectionIntegers_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdSobolDirectionIntegers_indexes_,
                    _xsd_XsdSobolDirectionIntegers_indexes_ + 10,
                    *this,
                    c));

  if (i == _xsd_XsdSobolDirectionIntegers_indexes_ + 10 || _xsd_XsdSobolDirectionIntegers_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdSobolDirectionIntegers::
_xsd_XsdSobolDirectionIntegers_literals_[10] =
{
  "JAECKEL",
  "JOE_KUO_D5",
  "JOE_KUO_D6",
  "JOE_KUO_D7",
  "KUO",
  "KUO2",
  "KUO3",
  "SOBOL_LEVITAN",
  "SOBOL_LEVITAN_LEMIEUX",
  "UNIT"
};

const XsdSobolDirectionIntegers::value XsdSobolDirectionIntegers::
_xsd_XsdSobolDirectionIntegers_indexes_[10] =
{
  ::XsdSobolDirectionIntegers::JAECKEL,
  ::XsdSobolDirectionIntegers::JOE_KUO_D5,
  ::XsdSobolDirectionIntegers::JOE_KUO_D6,
  ::XsdSobolDirectionIntegers::JOE_KUO_D7,
  ::XsdSobolDirectionIntegers::KUO,
  ::XsdSobolDirectionIntegers::KUO2,
  ::XsdSobolDirectionIntegers::KUO3,
  ::XsdSobolDirectionIntegers::SOBOL_LEVITAN,
  ::XsdSobolDirectionIntegers::SOBOL_LEVITAN_LEMIEUX,
  ::XsdSobolDirectionIntegers::UNIT
};

// XsdSolverType
//

XsdSolverType::
XsdSolverType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdSolverType_convert ();
}

XsdSolverType::
XsdSolverType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdSolverType_convert ();
}

XsdSolverType::
XsdSolverType (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdSolverType_convert ();
}

XsdSolverType* XsdSolverType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdSolverType (*this, f, c);
}

XsdSolverType::value XsdSolverType::
_xsd_XsdSolverType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdSolverType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdSolverType_indexes_,
                    _xsd_XsdSolverType_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_XsdSolverType_indexes_ + 6 || _xsd_XsdSolverType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdSolverType::
_xsd_XsdSolverType_literals_[6] =
{
  "ANALYTIC",
  "BINOMIAL",
  "INTEGRAL",
  "NONE",
  "PATH",
  "PDE"
};

const XsdSolverType::value XsdSolverType::
_xsd_XsdSolverType_indexes_[6] =
{
  ::XsdSolverType::ANALYTIC,
  ::XsdSolverType::BINOMIAL,
  ::XsdSolverType::INTEGRAL,
  ::XsdSolverType::NONE,
  ::XsdSolverType::PATH,
  ::XsdSolverType::PDE
};

// XsdValueRoot1DType
//

XsdValueRoot1DType::
XsdValueRoot1DType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdValueRoot1DType_convert ();
}

XsdValueRoot1DType::
XsdValueRoot1DType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdValueRoot1DType_convert ();
}

XsdValueRoot1DType::
XsdValueRoot1DType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdValueRoot1DType_convert ();
}

XsdValueRoot1DType* XsdValueRoot1DType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdValueRoot1DType (*this, f, c);
}

XsdValueRoot1DType::value XsdValueRoot1DType::
_xsd_XsdValueRoot1DType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdValueRoot1DType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdValueRoot1DType_indexes_,
                    _xsd_XsdValueRoot1DType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_XsdValueRoot1DType_indexes_ + 4 || _xsd_XsdValueRoot1DType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdValueRoot1DType::
_xsd_XsdValueRoot1DType_literals_[4] =
{
  "BISECTION",
  "BRENT",
  "FALSE_POSITION",
  "RIDDER"
};

const XsdValueRoot1DType::value XsdValueRoot1DType::
_xsd_XsdValueRoot1DType_indexes_[4] =
{
  ::XsdValueRoot1DType::BISECTION,
  ::XsdValueRoot1DType::BRENT,
  ::XsdValueRoot1DType::FALSE_POSITION,
  ::XsdValueRoot1DType::RIDDER
};

// XsdWaveletType
//

XsdWaveletType::
XsdWaveletType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XsdWaveletType_convert ();
}

XsdWaveletType::
XsdWaveletType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XsdWaveletType_convert ();
}

XsdWaveletType::
XsdWaveletType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XsdWaveletType_convert ();
}

XsdWaveletType* XsdWaveletType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class XsdWaveletType (*this, f, c);
}

XsdWaveletType::value XsdWaveletType::
_xsd_XsdWaveletType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XsdWaveletType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XsdWaveletType_indexes_,
                    _xsd_XsdWaveletType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_XsdWaveletType_indexes_ + 3 || _xsd_XsdWaveletType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XsdWaveletType::
_xsd_XsdWaveletType_literals_[3] =
{
  "BSPLINE",
  "DAUBECHIES",
  "HAAR"
};

const XsdWaveletType::value XsdWaveletType::
_xsd_XsdWaveletType_indexes_[3] =
{
  ::XsdWaveletType::BSPLINE,
  ::XsdWaveletType::DAUBECHIES,
  ::XsdWaveletType::HAAR
};

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

::std::ostream&
operator<< (::std::ostream& o, XsdAggregateType::value i)
{
  return o << XsdAggregateType::_xsd_XsdAggregateType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdAggregateType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdAmericanAnalyticType::value i)
{
  return o << XsdAmericanAnalyticType::_xsd_XsdAmericanAnalyticType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdAmericanAnalyticType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdAverageType::value i)
{
  return o << XsdAverageType::_xsd_XsdAverageType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdAverageType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdBinomialType::value i)
{
  return o << XsdBinomialType::_xsd_XsdBinomialType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdBinomialType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdConjugateGradientType::value i)
{
  return o << XsdConjugateGradientType::_xsd_XsdConjugateGradientType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdConjugateGradientType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdCopulaType::value i)
{
  return o << XsdCopulaType::_xsd_XsdCopulaType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdCopulaType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdCorrelationType::value i)
{
  return o << XsdCorrelationType::_xsd_XsdCorrelationType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdCorrelationType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdCubicBoundaryType::value i)
{
  return o << XsdCubicBoundaryType::_xsd_XsdCubicBoundaryType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdCubicBoundaryType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdCubicDerivativeType::value i)
{
  return o << XsdCubicDerivativeType::_xsd_XsdCubicDerivativeType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdCubicDerivativeType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdDifferenceType::value i)
{
  return o << XsdDifferenceType::_xsd_XsdDifferenceType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDifferenceType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdDistributionType::value i)
{
  return o << XsdDistributionType::_xsd_XsdDistributionType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdDistributionType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdEndpointType::value i)
{
  return o << XsdEndpointType::_xsd_XsdEndpointType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdEndpointType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdErrorType::value i)
{
  return o << XsdErrorType::_xsd_XsdErrorType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdErrorType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdEvolveType::value i)
{
  return o << XsdEvolveType::_xsd_XsdEvolveType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdEvolveType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdExtrapolate::value i)
{
  return o << XsdExtrapolate::_xsd_XsdExtrapolate_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdExtrapolate& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdFdmScheme::value i)
{
  return o << XsdFdmScheme::_xsd_XsdFdmScheme_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdFdmScheme& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdGammaRngType::value i)
{
  return o << XsdGammaRngType::_xsd_XsdGammaRngType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdGammaRngType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdGradientRoot1DType::value i)
{
  return o << XsdGradientRoot1DType::_xsd_XsdGradientRoot1DType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdGradientRoot1DType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMomentType::value i)
{
  return o << XsdMomentType::_xsd_XsdMomentType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMomentType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdPdeTimeScheme::value i)
{
  return o << XsdPdeTimeScheme::_xsd_XsdPdeTimeScheme_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdPdeTimeScheme& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdGaussKronrodRule::value i)
{
  return o << XsdGaussKronrodRule::_xsd_XsdGaussKronrodRule_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdGaussKronrodRule& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMinLinearBasis::value i)
{
  return o << XsdMinLinearBasis::_xsd_XsdMinLinearBasis_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMinLinearBasis& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMinLinearMethod::value i)
{
  return o << XsdMinLinearMethod::_xsd_XsdMinLinearMethod_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMinLinearMethod& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMinLinearScale::value i)
{
  return o << XsdMinLinearScale::_xsd_XsdMinLinearScale_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMinLinearScale& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMonteCarloRule::value i)
{
  return o << XsdMonteCarloRule::_xsd_XsdMonteCarloRule_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMonteCarloRule& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdMultiRootType::value i)
{
  return o << XsdMultiRootType::_xsd_XsdMultiRootType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdMultiRootType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdNormalRngType::value i)
{
  return o << XsdNormalRngType::_xsd_XsdNormalRngType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdNormalRngType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdOdeSolverType::value i)
{
  return o << XsdOdeSolverType::_xsd_XsdOdeSolverType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdOdeSolverType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdPathScheme::value i)
{
  return o << XsdPathScheme::_xsd_XsdPathScheme_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdPathScheme& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdRandomType::value i)
{
  return o << XsdRandomType::_xsd_XsdRandomType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdRandomType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdSalvageType::value i)
{
  return o << XsdSalvageType::_xsd_XsdSalvageType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSalvageType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdRoundType::value i)
{
  return o << XsdRoundType::_xsd_XsdRoundType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdRoundType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdSingularValueType::value i)
{
  return o << XsdSingularValueType::_xsd_XsdSingularValueType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSingularValueType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdSobolDirectionIntegers::value i)
{
  return o << XsdSobolDirectionIntegers::_xsd_XsdSobolDirectionIntegers_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSobolDirectionIntegers& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdSolverType::value i)
{
  return o << XsdSolverType::_xsd_XsdSolverType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdSolverType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdValueRoot1DType::value i)
{
  return o << XsdValueRoot1DType::_xsd_XsdValueRoot1DType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdValueRoot1DType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, XsdWaveletType::value i)
{
  return o << XsdWaveletType::_xsd_XsdWaveletType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const XsdWaveletType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (xercesc::DOMElement& e, const XsdAggregateType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdAggregateType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdAggregateType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdAmericanAnalyticType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdAmericanAnalyticType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdAmericanAnalyticType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdAverageType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdAverageType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdAverageType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdBinomialType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdBinomialType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdBinomialType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdConjugateGradientType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdConjugateGradientType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdConjugateGradientType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdCopulaType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdCopulaType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdCopulaType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdCorrelationType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdCorrelationType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdCorrelationType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdCubicBoundaryType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdCubicBoundaryType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdCubicBoundaryType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdCubicDerivativeType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdCubicDerivativeType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdCubicDerivativeType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdDifferenceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdDifferenceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdDifferenceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdDistributionType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdDistributionType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdDistributionType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdEndpointType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdEndpointType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdEndpointType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdErrorType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdErrorType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdErrorType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdEvolveType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdEvolveType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdEvolveType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdExtrapolate& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdExtrapolate& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdExtrapolate& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdFdmScheme& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdFdmScheme& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdFdmScheme& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdGammaRngType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdGammaRngType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdGammaRngType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdGradientRoot1DType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdGradientRoot1DType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdGradientRoot1DType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMomentType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMomentType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMomentType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdPdeTimeScheme& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdPdeTimeScheme& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdPdeTimeScheme& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdGaussKronrodRule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdGaussKronrodRule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdGaussKronrodRule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMinLinearBasis& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMinLinearBasis& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMinLinearBasis& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMinLinearMethod& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMinLinearMethod& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMinLinearMethod& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMinLinearScale& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMinLinearScale& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMinLinearScale& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMonteCarloRule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMonteCarloRule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMonteCarloRule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdMultiRootType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdMultiRootType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdMultiRootType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdNormalRngType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdNormalRngType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdNormalRngType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdOdeSolverType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdOdeSolverType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdOdeSolverType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdPathScheme& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdPathScheme& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdPathScheme& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdRandomType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdRandomType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdRandomType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdSalvageType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSalvageType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSalvageType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdRoundType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdRoundType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdRoundType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdSingularValueType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSingularValueType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSingularValueType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdSobolDirectionIntegers& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSobolDirectionIntegers& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSobolDirectionIntegers& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdSolverType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdSolverType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdSolverType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdValueRoot1DType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdValueRoot1DType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdValueRoot1DType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMElement& e, const XsdWaveletType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (xercesc::DOMAttr& a, const XsdWaveletType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const XsdWaveletType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

