// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_LINEAR_ALGEBRA_IXX
#define CXX___SCHEMA_XSD_MATH_LINEAR_ALGEBRA_IXX

// Begin prologue.
//
//
// End prologue.

#include "axis.ixx"

// XsdLinearSolver
// 


// XsdLinearTest
// 

inline
const XsdLinearTest::input_sequence& XsdLinearTest::
input () const
{
  return this->input_;
}

inline
XsdLinearTest::input_sequence& XsdLinearTest::
input ()
{
  return this->input_;
}

inline
void XsdLinearTest::
input (const input_sequence& s)
{
  this->input_ = s;
}

inline
const XsdLinearTest::determinant_optional& XsdLinearTest::
determinant () const
{
  return this->determinant_;
}

inline
XsdLinearTest::determinant_optional& XsdLinearTest::
determinant ()
{
  return this->determinant_;
}

inline
void XsdLinearTest::
determinant (const determinant_type& x)
{
  this->determinant_.set (x);
}

inline
void XsdLinearTest::
determinant (const determinant_optional& x)
{
  this->determinant_ = x;
}

inline
XsdLinearTest::determinant_type XsdLinearTest::
determinant_default_value ()
{
  return determinant_type (false);
}

inline
const XsdLinearTest::decomposition_optional& XsdLinearTest::
decomposition () const
{
  return this->decomposition_;
}

inline
XsdLinearTest::decomposition_optional& XsdLinearTest::
decomposition ()
{
  return this->decomposition_;
}

inline
void XsdLinearTest::
decomposition (const decomposition_type& x)
{
  this->decomposition_.set (x);
}

inline
void XsdLinearTest::
decomposition (const decomposition_optional& x)
{
  this->decomposition_ = x;
}

inline
XsdLinearTest::decomposition_type XsdLinearTest::
decomposition_default_value ()
{
  return decomposition_type (false);
}


// XsdLUDecompTest
// 

inline
const XsdLUDecompTest::result_optional& XsdLUDecompTest::
result () const
{
  return this->result_;
}

inline
XsdLUDecompTest::result_optional& XsdLUDecompTest::
result ()
{
  return this->result_;
}

inline
void XsdLUDecompTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdLUDecompTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdLUDecompTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdLUDecompTest::matrix_type& XsdLUDecompTest::
matrix () const
{
  return this->matrix_.get ();
}

inline
XsdLUDecompTest::matrix_type& XsdLUDecompTest::
matrix ()
{
  return this->matrix_.get ();
}

inline
void XsdLUDecompTest::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

inline
void XsdLUDecompTest::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}


// XsdCholeskyTest
// 

inline
const XsdCholeskyTest::result_optional& XsdCholeskyTest::
result () const
{
  return this->result_;
}

inline
XsdCholeskyTest::result_optional& XsdCholeskyTest::
result ()
{
  return this->result_;
}

inline
void XsdCholeskyTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdCholeskyTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdCholeskyTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdCholeskyTest::matrix_type& XsdCholeskyTest::
matrix () const
{
  return this->matrix_.get ();
}

inline
XsdCholeskyTest::matrix_type& XsdCholeskyTest::
matrix ()
{
  return this->matrix_.get ();
}

inline
void XsdCholeskyTest::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

inline
void XsdCholeskyTest::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}


// XsdQRDecompTest
// 

inline
const XsdQRDecompTest::result_optional& XsdQRDecompTest::
result () const
{
  return this->result_;
}

inline
XsdQRDecompTest::result_optional& XsdQRDecompTest::
result ()
{
  return this->result_;
}

inline
void XsdQRDecompTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdQRDecompTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdQRDecompTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdQRDecompTest::matrix_type& XsdQRDecompTest::
matrix () const
{
  return this->matrix_.get ();
}

inline
XsdQRDecompTest::matrix_type& XsdQRDecompTest::
matrix ()
{
  return this->matrix_.get ();
}

inline
void XsdQRDecompTest::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

inline
void XsdQRDecompTest::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}


// XsdSVDecompTest
// 

inline
const XsdSVDecompTest::result_optional& XsdSVDecompTest::
result () const
{
  return this->result_;
}

inline
XsdSVDecompTest::result_optional& XsdSVDecompTest::
result ()
{
  return this->result_;
}

inline
void XsdSVDecompTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdSVDecompTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdSVDecompTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdSVDecompTest::matrix_type& XsdSVDecompTest::
matrix () const
{
  return this->matrix_.get ();
}

inline
XsdSVDecompTest::matrix_type& XsdSVDecompTest::
matrix ()
{
  return this->matrix_.get ();
}

inline
void XsdSVDecompTest::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

inline
void XsdSVDecompTest::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}

inline
const XsdSVDecompTest::method_optional& XsdSVDecompTest::
method () const
{
  return this->method_;
}

inline
XsdSVDecompTest::method_optional& XsdSVDecompTest::
method ()
{
  return this->method_;
}

inline
void XsdSVDecompTest::
method (const method_type& x)
{
  this->method_.set (x);
}

inline
void XsdSVDecompTest::
method (const method_optional& x)
{
  this->method_ = x;
}

inline
void XsdSVDecompTest::
method (::std::auto_ptr< method_type > x)
{
  this->method_.set (x);
}

inline
const XsdSVDecompTest::method_type& XsdSVDecompTest::
method_default_value ()
{
  return method_default_value_;
}


// XsdVandermondeTest
// 

inline
const XsdVandermondeTest::result_optional& XsdVandermondeTest::
result () const
{
  return this->result_;
}

inline
XsdVandermondeTest::result_optional& XsdVandermondeTest::
result ()
{
  return this->result_;
}

inline
void XsdVandermondeTest::
result (const result_type& x)
{
  this->result_.set (x);
}

inline
void XsdVandermondeTest::
result (const result_optional& x)
{
  this->result_ = x;
}

inline
void XsdVandermondeTest::
result (::std::auto_ptr< result_type > x)
{
  this->result_.set (x);
}

inline
const XsdVandermondeTest::axis_type& XsdVandermondeTest::
axis () const
{
  return this->axis_.get ();
}

inline
XsdVandermondeTest::axis_type& XsdVandermondeTest::
axis ()
{
  return this->axis_.get ();
}

inline
void XsdVandermondeTest::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

inline
void XsdVandermondeTest::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}


// XsdPseudoSqrtTest
// 

inline
const XsdPseudoSqrtTest::matrix_type& XsdPseudoSqrtTest::
matrix () const
{
  return this->matrix_.get ();
}

inline
XsdPseudoSqrtTest::matrix_type& XsdPseudoSqrtTest::
matrix ()
{
  return this->matrix_.get ();
}

inline
void XsdPseudoSqrtTest::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

inline
void XsdPseudoSqrtTest::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}

inline
const XsdPseudoSqrtTest::rank_optional& XsdPseudoSqrtTest::
rank () const
{
  return this->rank_;
}

inline
XsdPseudoSqrtTest::rank_optional& XsdPseudoSqrtTest::
rank ()
{
  return this->rank_;
}

inline
void XsdPseudoSqrtTest::
rank (const rank_type& x)
{
  this->rank_.set (x);
}

inline
void XsdPseudoSqrtTest::
rank (const rank_optional& x)
{
  this->rank_ = x;
}

inline
XsdPseudoSqrtTest::rank_type XsdPseudoSqrtTest::
rank_default_value ()
{
  return rank_type (1ULL);
}

inline
const XsdPseudoSqrtTest::retain_optional& XsdPseudoSqrtTest::
retain () const
{
  return this->retain_;
}

inline
XsdPseudoSqrtTest::retain_optional& XsdPseudoSqrtTest::
retain ()
{
  return this->retain_;
}

inline
void XsdPseudoSqrtTest::
retain (const retain_type& x)
{
  this->retain_.set (x);
}

inline
void XsdPseudoSqrtTest::
retain (const retain_optional& x)
{
  this->retain_ = x;
}

inline
XsdPseudoSqrtTest::retain_type XsdPseudoSqrtTest::
retain_default_value ()
{
  return retain_type (true);
}

inline
const XsdPseudoSqrtTest::salvage_optional& XsdPseudoSqrtTest::
salvage () const
{
  return this->salvage_;
}

inline
XsdPseudoSqrtTest::salvage_optional& XsdPseudoSqrtTest::
salvage ()
{
  return this->salvage_;
}

inline
void XsdPseudoSqrtTest::
salvage (const salvage_type& x)
{
  this->salvage_.set (x);
}

inline
void XsdPseudoSqrtTest::
salvage (const salvage_optional& x)
{
  this->salvage_ = x;
}

inline
void XsdPseudoSqrtTest::
salvage (::std::auto_ptr< salvage_type > x)
{
  this->salvage_.set (x);
}


// XsdLinearResult
// 

inline
const XsdLinearResult::solution_sequence& XsdLinearResult::
solution () const
{
  return this->solution_;
}

inline
XsdLinearResult::solution_sequence& XsdLinearResult::
solution ()
{
  return this->solution_;
}

inline
void XsdLinearResult::
solution (const solution_sequence& s)
{
  this->solution_ = s;
}

inline
const XsdLinearResult::determinant_optional& XsdLinearResult::
determinant () const
{
  return this->determinant_;
}

inline
XsdLinearResult::determinant_optional& XsdLinearResult::
determinant ()
{
  return this->determinant_;
}

inline
void XsdLinearResult::
determinant (const determinant_type& x)
{
  this->determinant_.set (x);
}

inline
void XsdLinearResult::
determinant (const determinant_optional& x)
{
  this->determinant_ = x;
}


// XsdCholeskyResult
// 

inline
const XsdCholeskyResult::factor_optional& XsdCholeskyResult::
factor () const
{
  return this->factor_;
}

inline
XsdCholeskyResult::factor_optional& XsdCholeskyResult::
factor ()
{
  return this->factor_;
}

inline
void XsdCholeskyResult::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

inline
void XsdCholeskyResult::
factor (const factor_optional& x)
{
  this->factor_ = x;
}

inline
void XsdCholeskyResult::
factor (::std::auto_ptr< factor_type > x)
{
  this->factor_.set (x);
}


// XsdQRDecompResult
// 

inline
const XsdQRDecompResult::Q_optional& XsdQRDecompResult::
Q () const
{
  return this->Q_;
}

inline
XsdQRDecompResult::Q_optional& XsdQRDecompResult::
Q ()
{
  return this->Q_;
}

inline
void XsdQRDecompResult::
Q (const Q_type& x)
{
  this->Q_.set (x);
}

inline
void XsdQRDecompResult::
Q (const Q_optional& x)
{
  this->Q_ = x;
}

inline
void XsdQRDecompResult::
Q (::std::auto_ptr< Q_type > x)
{
  this->Q_.set (x);
}

inline
const XsdQRDecompResult::R_optional& XsdQRDecompResult::
R () const
{
  return this->R_;
}

inline
XsdQRDecompResult::R_optional& XsdQRDecompResult::
R ()
{
  return this->R_;
}

inline
void XsdQRDecompResult::
R (const R_type& x)
{
  this->R_.set (x);
}

inline
void XsdQRDecompResult::
R (const R_optional& x)
{
  this->R_ = x;
}

inline
void XsdQRDecompResult::
R (::std::auto_ptr< R_type > x)
{
  this->R_.set (x);
}


// XsdSVDecompResult
// 

inline
const XsdSVDecompResult::U_optional& XsdSVDecompResult::
U () const
{
  return this->U_;
}

inline
XsdSVDecompResult::U_optional& XsdSVDecompResult::
U ()
{
  return this->U_;
}

inline
void XsdSVDecompResult::
U (const U_type& x)
{
  this->U_.set (x);
}

inline
void XsdSVDecompResult::
U (const U_optional& x)
{
  this->U_ = x;
}

inline
void XsdSVDecompResult::
U (::std::auto_ptr< U_type > x)
{
  this->U_.set (x);
}

inline
const XsdSVDecompResult::V_optional& XsdSVDecompResult::
V () const
{
  return this->V_;
}

inline
XsdSVDecompResult::V_optional& XsdSVDecompResult::
V ()
{
  return this->V_;
}

inline
void XsdSVDecompResult::
V (const V_type& x)
{
  this->V_.set (x);
}

inline
void XsdSVDecompResult::
V (const V_optional& x)
{
  this->V_ = x;
}

inline
void XsdSVDecompResult::
V (::std::auto_ptr< V_type > x)
{
  this->V_.set (x);
}

inline
const XsdSVDecompResult::sigma_optional& XsdSVDecompResult::
sigma () const
{
  return this->sigma_;
}

inline
XsdSVDecompResult::sigma_optional& XsdSVDecompResult::
sigma ()
{
  return this->sigma_;
}

inline
void XsdSVDecompResult::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

inline
void XsdSVDecompResult::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

inline
void XsdSVDecompResult::
sigma (::std::auto_ptr< sigma_type > x)
{
  this->sigma_.set (x);
}


// XsdPseudoSqrtResult
// 

inline
const XsdPseudoSqrtResult::factor_optional& XsdPseudoSqrtResult::
factor () const
{
  return this->factor_;
}

inline
XsdPseudoSqrtResult::factor_optional& XsdPseudoSqrtResult::
factor ()
{
  return this->factor_;
}

inline
void XsdPseudoSqrtResult::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

inline
void XsdPseudoSqrtResult::
factor (const factor_optional& x)
{
  this->factor_ = x;
}

inline
void XsdPseudoSqrtResult::
factor (::std::auto_ptr< factor_type > x)
{
  this->factor_.set (x);
}


// XsdLinearRow
// 

inline
const XsdLinearRow::l2Error_optional& XsdLinearRow::
l2Error () const
{
  return this->l2Error_;
}

inline
XsdLinearRow::l2Error_optional& XsdLinearRow::
l2Error ()
{
  return this->l2Error_;
}

inline
void XsdLinearRow::
l2Error (const l2Error_type& x)
{
  this->l2Error_.set (x);
}

inline
void XsdLinearRow::
l2Error (const l2Error_optional& x)
{
  this->l2Error_ = x;
}

inline
const XsdLinearRow::maxError_optional& XsdLinearRow::
maxError () const
{
  return this->maxError_;
}

inline
XsdLinearRow::maxError_optional& XsdLinearRow::
maxError ()
{
  return this->maxError_;
}

inline
void XsdLinearRow::
maxError (const maxError_type& x)
{
  this->maxError_.set (x);
}

inline
void XsdLinearRow::
maxError (const maxError_optional& x)
{
  this->maxError_ = x;
}


// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_LINEAR_ALGEBRA_IXX
