// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_SOLVER_IXX
#define CXX___SCHEMA_XSD_MATH_SOLVER_IXX

// Begin prologue.
//
//
// End prologue.

#include "stochastic.ixx"

// XsdSolver
// 

inline
const XsdSolver::process_optional& XsdSolver::
process () const
{
  return this->process_;
}

inline
XsdSolver::process_optional& XsdSolver::
process ()
{
  return this->process_;
}

inline
void XsdSolver::
process (const process_type& x)
{
  this->process_.set (x);
}

inline
void XsdSolver::
process (const process_optional& x)
{
  this->process_ = x;
}

inline
void XsdSolver::
process (::std::auto_ptr< process_type > x)
{
  this->process_.set (x);
}


// XsdAnalyticSolver
// 

inline
const XsdAnalyticSolver::american_optional& XsdAnalyticSolver::
american () const
{
  return this->american_;
}

inline
XsdAnalyticSolver::american_optional& XsdAnalyticSolver::
american ()
{
  return this->american_;
}

inline
void XsdAnalyticSolver::
american (const american_type& x)
{
  this->american_.set (x);
}

inline
void XsdAnalyticSolver::
american (const american_optional& x)
{
  this->american_ = x;
}

inline
void XsdAnalyticSolver::
american (::std::auto_ptr< american_type > x)
{
  this->american_.set (x);
}

inline
const XsdAnalyticSolver::american_type& XsdAnalyticSolver::
american_default_value ()
{
  return american_default_value_;
}


// XsdBinomialSolver
// 

inline
const XsdBinomialSolver::minSteps_optional& XsdBinomialSolver::
minSteps () const
{
  return this->minSteps_;
}

inline
XsdBinomialSolver::minSteps_optional& XsdBinomialSolver::
minSteps ()
{
  return this->minSteps_;
}

inline
void XsdBinomialSolver::
minSteps (const minSteps_type& x)
{
  this->minSteps_.set (x);
}

inline
void XsdBinomialSolver::
minSteps (const minSteps_optional& x)
{
  this->minSteps_ = x;
}

inline
XsdBinomialSolver::minSteps_type XsdBinomialSolver::
minSteps_default_value ()
{
  return minSteps_type (3ULL);
}

inline
const XsdBinomialSolver::maxSteps_optional& XsdBinomialSolver::
maxSteps () const
{
  return this->maxSteps_;
}

inline
XsdBinomialSolver::maxSteps_optional& XsdBinomialSolver::
maxSteps ()
{
  return this->maxSteps_;
}

inline
void XsdBinomialSolver::
maxSteps (const maxSteps_type& x)
{
  this->maxSteps_.set (x);
}

inline
void XsdBinomialSolver::
maxSteps (const maxSteps_optional& x)
{
  this->maxSteps_ = x;
}

inline
XsdBinomialSolver::maxSteps_type XsdBinomialSolver::
maxSteps_default_value ()
{
  return maxSteps_type (360ULL);
}

inline
const XsdBinomialSolver::stepsPerYear_optional& XsdBinomialSolver::
stepsPerYear () const
{
  return this->stepsPerYear_;
}

inline
XsdBinomialSolver::stepsPerYear_optional& XsdBinomialSolver::
stepsPerYear ()
{
  return this->stepsPerYear_;
}

inline
void XsdBinomialSolver::
stepsPerYear (const stepsPerYear_type& x)
{
  this->stepsPerYear_.set (x);
}

inline
void XsdBinomialSolver::
stepsPerYear (const stepsPerYear_optional& x)
{
  this->stepsPerYear_ = x;
}

inline
XsdBinomialSolver::stepsPerYear_type XsdBinomialSolver::
stepsPerYear_default_value ()
{
  return stepsPerYear_type (12ULL);
}

inline
const XsdBinomialSolver::type_optional& XsdBinomialSolver::
type () const
{
  return this->type_;
}

inline
XsdBinomialSolver::type_optional& XsdBinomialSolver::
type ()
{
  return this->type_;
}

inline
void XsdBinomialSolver::
type (const type_type& x)
{
  this->type_.set (x);
}

inline
void XsdBinomialSolver::
type (const type_optional& x)
{
  this->type_ = x;
}

inline
void XsdBinomialSolver::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

inline
const XsdBinomialSolver::type_type& XsdBinomialSolver::
type_default_value ()
{
  return type_default_value_;
}


// XsdIntegralSolver
// 

inline
const XsdIntegralSolver::range_optional& XsdIntegralSolver::
range () const
{
  return this->range_;
}

inline
XsdIntegralSolver::range_optional& XsdIntegralSolver::
range ()
{
  return this->range_;
}

inline
void XsdIntegralSolver::
range (const range_type& x)
{
  this->range_.set (x);
}

inline
void XsdIntegralSolver::
range (const range_optional& x)
{
  this->range_ = x;
}

inline
void XsdIntegralSolver::
range (::std::auto_ptr< range_type > x)
{
  this->range_.set (x);
}

inline
XsdIntegralSolver::range_type XsdIntegralSolver::
range_default_value ()
{
  return range_type (5.0);
}

inline
const XsdIntegralSolver::numPoints_optional& XsdIntegralSolver::
numPoints () const
{
  return this->numPoints_;
}

inline
XsdIntegralSolver::numPoints_optional& XsdIntegralSolver::
numPoints ()
{
  return this->numPoints_;
}

inline
void XsdIntegralSolver::
numPoints (const numPoints_type& x)
{
  this->numPoints_.set (x);
}

inline
void XsdIntegralSolver::
numPoints (const numPoints_optional& x)
{
  this->numPoints_ = x;
}

inline
XsdIntegralSolver::numPoints_type XsdIntegralSolver::
numPoints_default_value ()
{
  return numPoints_type (100ULL);
}


// XsdPathSolver
// 

inline
const XsdPathSolver::timeSteps_optional& XsdPathSolver::
timeSteps () const
{
  return this->timeSteps_;
}

inline
XsdPathSolver::timeSteps_optional& XsdPathSolver::
timeSteps ()
{
  return this->timeSteps_;
}

inline
void XsdPathSolver::
timeSteps (const timeSteps_type& x)
{
  this->timeSteps_.set (x);
}

inline
void XsdPathSolver::
timeSteps (const timeSteps_optional& x)
{
  this->timeSteps_ = x;
}

inline
XsdPathSolver::timeSteps_type XsdPathSolver::
timeSteps_default_value ()
{
  return timeSteps_type (100ULL);
}

inline
const XsdPathSolver::timeStepsPerYear_optional& XsdPathSolver::
timeStepsPerYear () const
{
  return this->timeStepsPerYear_;
}

inline
XsdPathSolver::timeStepsPerYear_optional& XsdPathSolver::
timeStepsPerYear ()
{
  return this->timeStepsPerYear_;
}

inline
void XsdPathSolver::
timeStepsPerYear (const timeStepsPerYear_type& x)
{
  this->timeStepsPerYear_.set (x);
}

inline
void XsdPathSolver::
timeStepsPerYear (const timeStepsPerYear_optional& x)
{
  this->timeStepsPerYear_ = x;
}

inline
XsdPathSolver::timeStepsPerYear_type XsdPathSolver::
timeStepsPerYear_default_value ()
{
  return timeStepsPerYear_type (12ULL);
}

inline
const XsdPathSolver::brownianBridge_optional& XsdPathSolver::
brownianBridge () const
{
  return this->brownianBridge_;
}

inline
XsdPathSolver::brownianBridge_optional& XsdPathSolver::
brownianBridge ()
{
  return this->brownianBridge_;
}

inline
void XsdPathSolver::
brownianBridge (const brownianBridge_type& x)
{
  this->brownianBridge_.set (x);
}

inline
void XsdPathSolver::
brownianBridge (const brownianBridge_optional& x)
{
  this->brownianBridge_ = x;
}

inline
XsdPathSolver::brownianBridge_type XsdPathSolver::
brownianBridge_default_value ()
{
  return brownianBridge_type (false);
}

inline
const XsdPathSolver::antithetic_optional& XsdPathSolver::
antithetic () const
{
  return this->antithetic_;
}

inline
XsdPathSolver::antithetic_optional& XsdPathSolver::
antithetic ()
{
  return this->antithetic_;
}

inline
void XsdPathSolver::
antithetic (const antithetic_type& x)
{
  this->antithetic_.set (x);
}

inline
void XsdPathSolver::
antithetic (const antithetic_optional& x)
{
  this->antithetic_ = x;
}

inline
XsdPathSolver::antithetic_type XsdPathSolver::
antithetic_default_value ()
{
  return antithetic_type (false);
}

inline
const XsdPathSolver::minPaths_optional& XsdPathSolver::
minPaths () const
{
  return this->minPaths_;
}

inline
XsdPathSolver::minPaths_optional& XsdPathSolver::
minPaths ()
{
  return this->minPaths_;
}

inline
void XsdPathSolver::
minPaths (const minPaths_type& x)
{
  this->minPaths_.set (x);
}

inline
void XsdPathSolver::
minPaths (const minPaths_optional& x)
{
  this->minPaths_ = x;
}

inline
XsdPathSolver::minPaths_type XsdPathSolver::
minPaths_default_value ()
{
  return minPaths_type (1000ULL);
}

inline
const XsdPathSolver::maxPaths_optional& XsdPathSolver::
maxPaths () const
{
  return this->maxPaths_;
}

inline
XsdPathSolver::maxPaths_optional& XsdPathSolver::
maxPaths ()
{
  return this->maxPaths_;
}

inline
void XsdPathSolver::
maxPaths (const maxPaths_type& x)
{
  this->maxPaths_.set (x);
}

inline
void XsdPathSolver::
maxPaths (const maxPaths_optional& x)
{
  this->maxPaths_ = x;
}

inline
XsdPathSolver::maxPaths_type XsdPathSolver::
maxPaths_default_value ()
{
  return maxPaths_type (1000000ULL);
}

inline
const XsdPathSolver::tolerance_optional& XsdPathSolver::
tolerance () const
{
  return this->tolerance_;
}

inline
XsdPathSolver::tolerance_optional& XsdPathSolver::
tolerance ()
{
  return this->tolerance_;
}

inline
void XsdPathSolver::
tolerance (const tolerance_type& x)
{
  this->tolerance_.set (x);
}

inline
void XsdPathSolver::
tolerance (const tolerance_optional& x)
{
  this->tolerance_ = x;
}

inline
XsdPathSolver::tolerance_type XsdPathSolver::
tolerance_default_value ()
{
  return tolerance_type (.01);
}

inline
const XsdPathSolver::seed_optional& XsdPathSolver::
seed () const
{
  return this->seed_;
}

inline
XsdPathSolver::seed_optional& XsdPathSolver::
seed ()
{
  return this->seed_;
}

inline
void XsdPathSolver::
seed (const seed_type& x)
{
  this->seed_.set (x);
}

inline
void XsdPathSolver::
seed (const seed_optional& x)
{
  this->seed_ = x;
}

inline
XsdPathSolver::seed_type XsdPathSolver::
seed_default_value ()
{
  return seed_type (42LL);
}


// XsdPdeSolver
// 

inline
const XsdPdeSolver::timeSteps_optional& XsdPdeSolver::
timeSteps () const
{
  return this->timeSteps_;
}

inline
XsdPdeSolver::timeSteps_optional& XsdPdeSolver::
timeSteps ()
{
  return this->timeSteps_;
}

inline
void XsdPdeSolver::
timeSteps (const timeSteps_type& x)
{
  this->timeSteps_.set (x);
}

inline
void XsdPdeSolver::
timeSteps (const timeSteps_optional& x)
{
  this->timeSteps_ = x;
}

inline
XsdPdeSolver::timeSteps_type XsdPdeSolver::
timeSteps_default_value ()
{
  return timeSteps_type (100ULL);
}

inline
const XsdPdeSolver::xGridPoints_optional& XsdPdeSolver::
xGridPoints () const
{
  return this->xGridPoints_;
}

inline
XsdPdeSolver::xGridPoints_optional& XsdPdeSolver::
xGridPoints ()
{
  return this->xGridPoints_;
}

inline
void XsdPdeSolver::
xGridPoints (const xGridPoints_type& x)
{
  this->xGridPoints_.set (x);
}

inline
void XsdPdeSolver::
xGridPoints (const xGridPoints_optional& x)
{
  this->xGridPoints_ = x;
}

inline
XsdPdeSolver::xGridPoints_type XsdPdeSolver::
xGridPoints_default_value ()
{
  return xGridPoints_type (100ULL);
}

inline
const XsdPdeSolver::yGridPoints_optional& XsdPdeSolver::
yGridPoints () const
{
  return this->yGridPoints_;
}

inline
XsdPdeSolver::yGridPoints_optional& XsdPdeSolver::
yGridPoints ()
{
  return this->yGridPoints_;
}

inline
void XsdPdeSolver::
yGridPoints (const yGridPoints_type& x)
{
  this->yGridPoints_.set (x);
}

inline
void XsdPdeSolver::
yGridPoints (const yGridPoints_optional& x)
{
  this->yGridPoints_ = x;
}

inline
XsdPdeSolver::yGridPoints_type XsdPdeSolver::
yGridPoints_default_value ()
{
  return yGridPoints_type (50ULL);
}

inline
const XsdPdeSolver::zGridPoints_optional& XsdPdeSolver::
zGridPoints () const
{
  return this->zGridPoints_;
}

inline
XsdPdeSolver::zGridPoints_optional& XsdPdeSolver::
zGridPoints ()
{
  return this->zGridPoints_;
}

inline
void XsdPdeSolver::
zGridPoints (const zGridPoints_type& x)
{
  this->zGridPoints_.set (x);
}

inline
void XsdPdeSolver::
zGridPoints (const zGridPoints_optional& x)
{
  this->zGridPoints_ = x;
}

inline
XsdPdeSolver::zGridPoints_type XsdPdeSolver::
zGridPoints_default_value ()
{
  return zGridPoints_type (25ULL);
}

inline
const XsdPdeSolver::discretization_optional& XsdPdeSolver::
discretization () const
{
  return this->discretization_;
}

inline
XsdPdeSolver::discretization_optional& XsdPdeSolver::
discretization ()
{
  return this->discretization_;
}

inline
void XsdPdeSolver::
discretization (const discretization_type& x)
{
  this->discretization_.set (x);
}

inline
void XsdPdeSolver::
discretization (const discretization_optional& x)
{
  this->discretization_ = x;
}

inline
void XsdPdeSolver::
discretization (::std::auto_ptr< discretization_type > x)
{
  this->discretization_.set (x);
}

inline
const XsdPdeSolver::discretization_type& XsdPdeSolver::
discretization_default_value ()
{
  return discretization_default_value_;
}

inline
const XsdPdeSolver::timeWeight_optional& XsdPdeSolver::
timeWeight () const
{
  return this->timeWeight_;
}

inline
XsdPdeSolver::timeWeight_optional& XsdPdeSolver::
timeWeight ()
{
  return this->timeWeight_;
}

inline
void XsdPdeSolver::
timeWeight (const timeWeight_type& x)
{
  this->timeWeight_.set (x);
}

inline
void XsdPdeSolver::
timeWeight (const timeWeight_optional& x)
{
  this->timeWeight_ = x;
}

inline
void XsdPdeSolver::
timeWeight (::std::auto_ptr< timeWeight_type > x)
{
  this->timeWeight_.set (x);
}

inline
XsdPdeSolver::timeWeight_type XsdPdeSolver::
timeWeight_default_value ()
{
  return timeWeight_type (.5);
}

inline
const XsdPdeSolver::scheme_optional& XsdPdeSolver::
scheme () const
{
  return this->scheme_;
}

inline
XsdPdeSolver::scheme_optional& XsdPdeSolver::
scheme ()
{
  return this->scheme_;
}

inline
void XsdPdeSolver::
scheme (const scheme_type& x)
{
  this->scheme_.set (x);
}

inline
void XsdPdeSolver::
scheme (const scheme_optional& x)
{
  this->scheme_ = x;
}

inline
void XsdPdeSolver::
scheme (::std::auto_ptr< scheme_type > x)
{
  this->scheme_.set (x);
}

inline
const XsdPdeSolver::scheme_type& XsdPdeSolver::
scheme_default_value ()
{
  return scheme_default_value_;
}

inline
const XsdPdeSolver::dampingSteps_optional& XsdPdeSolver::
dampingSteps () const
{
  return this->dampingSteps_;
}

inline
XsdPdeSolver::dampingSteps_optional& XsdPdeSolver::
dampingSteps ()
{
  return this->dampingSteps_;
}

inline
void XsdPdeSolver::
dampingSteps (const dampingSteps_type& x)
{
  this->dampingSteps_.set (x);
}

inline
void XsdPdeSolver::
dampingSteps (const dampingSteps_optional& x)
{
  this->dampingSteps_ = x;
}

inline
XsdPdeSolver::dampingSteps_type XsdPdeSolver::
dampingSteps_default_value ()
{
  return dampingSteps_type (0ULL);
}

inline
const XsdPdeSolver::mu_optional& XsdPdeSolver::
mu () const
{
  return this->mu_;
}

inline
XsdPdeSolver::mu_optional& XsdPdeSolver::
mu ()
{
  return this->mu_;
}

inline
void XsdPdeSolver::
mu (const mu_type& x)
{
  this->mu_.set (x);
}

inline
void XsdPdeSolver::
mu (const mu_optional& x)
{
  this->mu_ = x;
}

inline
XsdPdeSolver::mu_type XsdPdeSolver::
mu_default_value ()
{
  return mu_type (.5);
}


// range
// 


// timeWeight
// 


// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_SOLVER_IXX
