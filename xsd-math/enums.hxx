// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_ENUMS_HXX
#define CXX___SCHEMA_XSD_MATH_ENUMS_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdAggregateType;
class XsdAmericanAnalyticType;
class XsdAverageType;
class XsdBinomialType;
class XsdConjugateGradientType;
class XsdCopulaType;
class XsdCorrelationType;
class XsdCubicBoundaryType;
class XsdCubicDerivativeType;
class XsdDifferenceType;
class XsdDistributionType;
class XsdEndpointType;
class XsdErrorType;
class XsdEvolveType;
class XsdExtrapolate;
class XsdFdmScheme;
class XsdGammaRngType;
class XsdGradientRoot1DType;
class XsdMomentType;
class XsdPdeTimeScheme;
class XsdGaussKronrodRule;
class XsdMinLinearBasis;
class XsdMinLinearMethod;
class XsdMinLinearScale;
class XsdMonteCarloRule;
class XsdMultiRootType;
class XsdNormalRngType;
class XsdOdeSolverType;
class XsdPathScheme;
class XsdRandomType;
class XsdSalvageType;
class XsdRoundType;
class XsdSingularValueType;
class XsdSobolDirectionIntegers;
class XsdSolverType;
class XsdValueRoot1DType;
class XsdWaveletType;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "../xsd-core/enums.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "../xsd-core/enums.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdAggregateType: public ::xml_schema::string
{
  public:
  enum value
  {
    AVERAGE,
    MAXIMUM,
    MINIMUM,
    TOTAL
  };

  XsdAggregateType ();

  XsdAggregateType (value v);

  XsdAggregateType (const char* v);

  XsdAggregateType (const ::std::string& v);

  XsdAggregateType (const ::xml_schema::string& v);

  XsdAggregateType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdAggregateType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdAggregateType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdAggregateType (const XsdAggregateType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdAggregateType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdAggregateType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdAggregateType_convert ();
  }

  protected:
  value
  _xsd_XsdAggregateType_convert () const;

  public:
  static const char* const _xsd_XsdAggregateType_literals_[4];
  static const value _xsd_XsdAggregateType_indexes_[4];
};

class XsdAmericanAnalyticType: public ::xml_schema::string
{
  public:
  enum value
  {
    BARONE_ADESI_WHALEY,
    BJERKSUND_STENSLAND
  };

  XsdAmericanAnalyticType ();

  XsdAmericanAnalyticType (value v);

  XsdAmericanAnalyticType (const char* v);

  XsdAmericanAnalyticType (const ::std::string& v);

  XsdAmericanAnalyticType (const ::xml_schema::string& v);

  XsdAmericanAnalyticType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdAmericanAnalyticType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdAmericanAnalyticType (const ::std::string& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdAmericanAnalyticType (const XsdAmericanAnalyticType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual XsdAmericanAnalyticType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdAmericanAnalyticType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdAmericanAnalyticType_convert ();
  }

  protected:
  value
  _xsd_XsdAmericanAnalyticType_convert () const;

  public:
  static const char* const _xsd_XsdAmericanAnalyticType_literals_[2];
  static const value _xsd_XsdAmericanAnalyticType_indexes_[2];
};

class XsdAverageType: public ::xml_schema::string
{
  public:
  enum value
  {
    ARITHMETIC,
    GEOMETRIC,
    HARMONIC,
    MEDIAN
  };

  XsdAverageType ();

  XsdAverageType (value v);

  XsdAverageType (const char* v);

  XsdAverageType (const ::std::string& v);

  XsdAverageType (const ::xml_schema::string& v);

  XsdAverageType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdAverageType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdAverageType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdAverageType (const XsdAverageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdAverageType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdAverageType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdAverageType_convert ();
  }

  protected:
  value
  _xsd_XsdAverageType_convert () const;

  public:
  static const char* const _xsd_XsdAverageType_literals_[4];
  static const value _xsd_XsdAverageType_indexes_[4];
};

class XsdBinomialType: public ::xml_schema::string
{
  public:
  enum value
  {
    ADDITIVE_EQP,
    COX_ROSS_RUBINSTEIN,
    JARROW_RUDD,
    JOSHI4,
    LEISEN_REIMER,
    TIAN,
    TRIGEORGIS
  };

  XsdBinomialType ();

  XsdBinomialType (value v);

  XsdBinomialType (const char* v);

  XsdBinomialType (const ::std::string& v);

  XsdBinomialType (const ::xml_schema::string& v);

  XsdBinomialType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdBinomialType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdBinomialType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdBinomialType (const XsdBinomialType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdBinomialType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdBinomialType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdBinomialType_convert ();
  }

  protected:
  value
  _xsd_XsdBinomialType_convert () const;

  public:
  static const char* const _xsd_XsdBinomialType_literals_[7];
  static const value _xsd_XsdBinomialType_indexes_[7];
};

class XsdConjugateGradientType: public ::xml_schema::string
{
  public:
  enum value
  {
    FLETCHER_REEVES,
    POLAK_RIBIERE,
    BROYDEN_FLETCHER_GOLDFARB_SHANNO
  };

  XsdConjugateGradientType ();

  XsdConjugateGradientType (value v);

  XsdConjugateGradientType (const char* v);

  XsdConjugateGradientType (const ::std::string& v);

  XsdConjugateGradientType (const ::xml_schema::string& v);

  XsdConjugateGradientType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  XsdConjugateGradientType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  XsdConjugateGradientType (const ::std::string& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  XsdConjugateGradientType (const XsdConjugateGradientType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual XsdConjugateGradientType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdConjugateGradientType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdConjugateGradientType_convert ();
  }

  protected:
  value
  _xsd_XsdConjugateGradientType_convert () const;

  public:
  static const char* const _xsd_XsdConjugateGradientType_literals_[3];
  static const value _xsd_XsdConjugateGradientType_indexes_[3];
};

class XsdCopulaType: public ::xml_schema::string
{
  public:
  enum value
  {
    CLAYTON,
    DEPENDENT,
    DOUBLE_T,
    FRANK,
    GAUSSIAN,
    GUMBEL,
    INDEPENDENT,
    MARSHALL_OLKIN,
    MIXTURE,
    NIGAUSSIAN,
    STUDENT_T,
    VGAMMA
  };

  XsdCopulaType ();

  XsdCopulaType (value v);

  XsdCopulaType (const char* v);

  XsdCopulaType (const ::std::string& v);

  XsdCopulaType (const ::xml_schema::string& v);

  XsdCopulaType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdCopulaType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdCopulaType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdCopulaType (const XsdCopulaType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdCopulaType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdCopulaType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdCopulaType_convert ();
  }

  protected:
  value
  _xsd_XsdCopulaType_convert () const;

  public:
  static const char* const _xsd_XsdCopulaType_literals_[12];
  static const value _xsd_XsdCopulaType_indexes_[12];
};

class XsdCorrelationType: public ::xml_schema::string
{
  public:
  enum value
  {
    KENDALL,
    PEARSON,
    SPEARMAN
  };

  XsdCorrelationType ();

  XsdCorrelationType (value v);

  XsdCorrelationType (const char* v);

  XsdCorrelationType (const ::std::string& v);

  XsdCorrelationType (const ::xml_schema::string& v);

  XsdCorrelationType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdCorrelationType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdCorrelationType (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdCorrelationType (const XsdCorrelationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdCorrelationType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdCorrelationType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdCorrelationType_convert ();
  }

  protected:
  value
  _xsd_XsdCorrelationType_convert () const;

  public:
  static const char* const _xsd_XsdCorrelationType_literals_[3];
  static const value _xsd_XsdCorrelationType_indexes_[3];
};

class XsdCubicBoundaryType: public ::xml_schema::string
{
  public:
  enum value
  {
    DERIV_1ST,
    DERIV_2ND,
    NOT_A_KNOT,
    PERIODIC,
    LAGRANGE
  };

  XsdCubicBoundaryType ();

  XsdCubicBoundaryType (value v);

  XsdCubicBoundaryType (const char* v);

  XsdCubicBoundaryType (const ::std::string& v);

  XsdCubicBoundaryType (const ::xml_schema::string& v);

  XsdCubicBoundaryType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdCubicBoundaryType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdCubicBoundaryType (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdCubicBoundaryType (const XsdCubicBoundaryType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdCubicBoundaryType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdCubicBoundaryType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdCubicBoundaryType_convert ();
  }

  protected:
  value
  _xsd_XsdCubicBoundaryType_convert () const;

  public:
  static const char* const _xsd_XsdCubicBoundaryType_literals_[5];
  static const value _xsd_XsdCubicBoundaryType_indexes_[5];
};

class XsdCubicDerivativeType: public ::xml_schema::string
{
  public:
  enum value
  {
    AKIMA,
    FOURTH_ORDER,
    FRITSCH_BUTLAND,
    KRUGER,
    PARABOLIC,
    SPLINE,
    SPLINE_OM1,
    SPLINE_OM2
  };

  XsdCubicDerivativeType ();

  XsdCubicDerivativeType (value v);

  XsdCubicDerivativeType (const char* v);

  XsdCubicDerivativeType (const ::std::string& v);

  XsdCubicDerivativeType (const ::xml_schema::string& v);

  XsdCubicDerivativeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdCubicDerivativeType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdCubicDerivativeType (const ::std::string& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdCubicDerivativeType (const XsdCubicDerivativeType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual XsdCubicDerivativeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdCubicDerivativeType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdCubicDerivativeType_convert ();
  }

  protected:
  value
  _xsd_XsdCubicDerivativeType_convert () const;

  public:
  static const char* const _xsd_XsdCubicDerivativeType_literals_[8];
  static const value _xsd_XsdCubicDerivativeType_indexes_[8];
};

class XsdDifferenceType: public ::xml_schema::string
{
  public:
  enum value
  {
    BACKWARD,
    FORWARD,
    CENTRAL
  };

  XsdDifferenceType ();

  XsdDifferenceType (value v);

  XsdDifferenceType (const char* v);

  XsdDifferenceType (const ::std::string& v);

  XsdDifferenceType (const ::xml_schema::string& v);

  XsdDifferenceType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdDifferenceType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdDifferenceType (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdDifferenceType (const XsdDifferenceType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdDifferenceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdDifferenceType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdDifferenceType_convert ();
  }

  protected:
  value
  _xsd_XsdDifferenceType_convert () const;

  public:
  static const char* const _xsd_XsdDifferenceType_literals_[3];
  static const value _xsd_XsdDifferenceType_indexes_[3];
};

class XsdDistributionType: public ::xml_schema::string
{
  public:
  enum value
  {
    ASYMPTOTIC,
    BERNOULLI,
    BETA,
    BINOMIAL,
    CAUCHY,
    CHI_SQUARE,
    COMPOUND_POISSON,
    CONDITIONAL,
    CONVOLUTION,
    COPULA,
    COPULA_DISTRIBUTION,
    EMPIRICAL,
    EXPONENTIAL,
    EXP_POWER,
    EXTREME_VALUE,
    FISHER_F,
    GAMMA,
    GENERALIZED_INVERSE_GAUSSIAN,
    GENERIC,
    GUMBEL,
    INVERSE_CHI_SQUARE,
    INVERSE_GAMMA,
    INVERSE_GAUSSIAN,
    LAPLACE,
    LEVY_STABLE,
    LHPA_GAUSSIAN,
    LOGARITHMIC,
    LOGISTIC,
    LOGNORMAL,
    MIXTURE,
    NORMAL,
    NORMAL_GAMMA,
    NORMAL_INVERSE_GAUSSIAN,
    PARETO,
    POISSON,
    RAYLEIGH,
    SIMPLE,
    SPECIAL,
    STUDENT_T,
    TRIANGULAR,
    TRUNCATED,
    UNIFORM,
    VARIANCE_GAMMA,
    WEIBULL
  };

  XsdDistributionType ();

  XsdDistributionType (value v);

  XsdDistributionType (const char* v);

  XsdDistributionType (const ::std::string& v);

  XsdDistributionType (const ::xml_schema::string& v);

  XsdDistributionType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdDistributionType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdDistributionType (const ::std::string& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdDistributionType (const XsdDistributionType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual XsdDistributionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdDistributionType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdDistributionType_convert ();
  }

  protected:
  value
  _xsd_XsdDistributionType_convert () const;

  public:
  static const char* const _xsd_XsdDistributionType_literals_[44];
  static const value _xsd_XsdDistributionType_indexes_[44];
};

class XsdEndpointType: public ::xml_schema::string
{
  public:
  enum value
  {
    BOTH,
    LEFT,
    NONE,
    RIGHT
  };

  XsdEndpointType ();

  XsdEndpointType (value v);

  XsdEndpointType (const char* v);

  XsdEndpointType (const ::std::string& v);

  XsdEndpointType (const ::xml_schema::string& v);

  XsdEndpointType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdEndpointType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdEndpointType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdEndpointType (const XsdEndpointType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdEndpointType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdEndpointType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdEndpointType_convert ();
  }

  protected:
  value
  _xsd_XsdEndpointType_convert () const;

  public:
  static const char* const _xsd_XsdEndpointType_literals_[4];
  static const value _xsd_XsdEndpointType_indexes_[4];
};

class XsdErrorType: public ::xml_schema::string
{
  public:
  enum value
  {
    ABSOLUTE_PRICE,
    IMPLIED_VOLATILITY,
    RELATIVE_PRICE,
    UNKNOWN
  };

  XsdErrorType ();

  XsdErrorType (value v);

  XsdErrorType (const char* v);

  XsdErrorType (const ::std::string& v);

  XsdErrorType (const ::xml_schema::string& v);

  XsdErrorType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdErrorType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdErrorType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdErrorType (const XsdErrorType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual XsdErrorType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdErrorType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdErrorType_convert ();
  }

  protected:
  value
  _xsd_XsdErrorType_convert () const;

  public:
  static const char* const _xsd_XsdErrorType_literals_[4];
  static const value _xsd_XsdErrorType_indexes_[4];
};

class XsdEvolveType: public ::xml_schema::string
{
  public:
  enum value
  {
    EULER,
    EULER_END,
    MILSTEIN,
    PREDICTOR_CORRECTOR
  };

  XsdEvolveType ();

  XsdEvolveType (value v);

  XsdEvolveType (const char* v);

  XsdEvolveType (const ::std::string& v);

  XsdEvolveType (const ::xml_schema::string& v);

  XsdEvolveType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdEvolveType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdEvolveType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdEvolveType (const XsdEvolveType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdEvolveType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdEvolveType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdEvolveType_convert ();
  }

  protected:
  value
  _xsd_XsdEvolveType_convert () const;

  public:
  static const char* const _xsd_XsdEvolveType_literals_[4];
  static const value _xsd_XsdEvolveType_indexes_[4];
};

class XsdExtrapolate: public ::xml_schema::string
{
  public:
  enum value
  {
    CONSTANT,
    LINEAR,
    NONE,
    ZERO
  };

  XsdExtrapolate ();

  XsdExtrapolate (value v);

  XsdExtrapolate (const char* v);

  XsdExtrapolate (const ::std::string& v);

  XsdExtrapolate (const ::xml_schema::string& v);

  XsdExtrapolate (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdExtrapolate (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdExtrapolate (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdExtrapolate (const XsdExtrapolate& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdExtrapolate*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdExtrapolate&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdExtrapolate_convert ();
  }

  protected:
  value
  _xsd_XsdExtrapolate_convert () const;

  public:
  static const char* const _xsd_XsdExtrapolate_literals_[4];
  static const value _xsd_XsdExtrapolate_indexes_[4];
};

class XsdFdmScheme: public ::xml_schema::string
{
  public:
  enum value
  {
    CRAIG_SNEYD,
    CRAIG_SNEYD_MODIFIED,
    DOUGLAS,
    EULER_EXPLICIT,
    EULER_IMPLICIT,
    HUNDSDORFER
  };

  XsdFdmScheme ();

  XsdFdmScheme (value v);

  XsdFdmScheme (const char* v);

  XsdFdmScheme (const ::std::string& v);

  XsdFdmScheme (const ::xml_schema::string& v);

  XsdFdmScheme (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdFdmScheme (const xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdFdmScheme (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdFdmScheme (const XsdFdmScheme& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual XsdFdmScheme*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdFdmScheme&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdFdmScheme_convert ();
  }

  protected:
  value
  _xsd_XsdFdmScheme_convert () const;

  public:
  static const char* const _xsd_XsdFdmScheme_literals_[6];
  static const value _xsd_XsdFdmScheme_indexes_[6];
};

class XsdGammaRngType: public ::xml_schema::string
{
  public:
  enum value
  {
    DEFAULT,
    KNUTH,
    MARSAGLIA_TSANG
  };

  XsdGammaRngType ();

  XsdGammaRngType (value v);

  XsdGammaRngType (const char* v);

  XsdGammaRngType (const ::std::string& v);

  XsdGammaRngType (const ::xml_schema::string& v);

  XsdGammaRngType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdGammaRngType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdGammaRngType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  XsdGammaRngType (const XsdGammaRngType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual XsdGammaRngType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdGammaRngType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdGammaRngType_convert ();
  }

  protected:
  value
  _xsd_XsdGammaRngType_convert () const;

  public:
  static const char* const _xsd_XsdGammaRngType_literals_[3];
  static const value _xsd_XsdGammaRngType_indexes_[3];
};

class XsdGradientRoot1DType: public ::xml_schema::string
{
  public:
  enum value
  {
    NEWTON,
    SECANT,
    STEFFENSON
  };

  XsdGradientRoot1DType ();

  XsdGradientRoot1DType (value v);

  XsdGradientRoot1DType (const char* v);

  XsdGradientRoot1DType (const ::std::string& v);

  XsdGradientRoot1DType (const ::xml_schema::string& v);

  XsdGradientRoot1DType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdGradientRoot1DType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdGradientRoot1DType (const ::std::string& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  XsdGradientRoot1DType (const XsdGradientRoot1DType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual XsdGradientRoot1DType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdGradientRoot1DType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdGradientRoot1DType_convert ();
  }

  protected:
  value
  _xsd_XsdGradientRoot1DType_convert () const;

  public:
  static const char* const _xsd_XsdGradientRoot1DType_literals_[3];
  static const value _xsd_XsdGradientRoot1DType_indexes_[3];
};

class XsdMomentType: public ::xml_schema::string
{
  public:
  enum value
  {
    MEAN,
    VARIANCE,
    SKEWNESS,
    KURTOSIS
  };

  XsdMomentType ();

  XsdMomentType (value v);

  XsdMomentType (const char* v);

  XsdMomentType (const ::std::string& v);

  XsdMomentType (const ::xml_schema::string& v);

  XsdMomentType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdMomentType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdMomentType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdMomentType (const XsdMomentType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdMomentType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMomentType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMomentType_convert ();
  }

  protected:
  value
  _xsd_XsdMomentType_convert () const;

  public:
  static const char* const _xsd_XsdMomentType_literals_[4];
  static const value _xsd_XsdMomentType_indexes_[4];
};

class XsdPdeTimeScheme: public ::xml_schema::string
{
  public:
  enum value
  {
    CRANK_NICOLSON,
    EXPLICIT_EULER,
    IMPLICIT_EULER
  };

  XsdPdeTimeScheme ();

  XsdPdeTimeScheme (value v);

  XsdPdeTimeScheme (const char* v);

  XsdPdeTimeScheme (const ::std::string& v);

  XsdPdeTimeScheme (const ::xml_schema::string& v);

  XsdPdeTimeScheme (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdPdeTimeScheme (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdPdeTimeScheme (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdPdeTimeScheme (const XsdPdeTimeScheme& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdPdeTimeScheme*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdPdeTimeScheme&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdPdeTimeScheme_convert ();
  }

  protected:
  value
  _xsd_XsdPdeTimeScheme_convert () const;

  public:
  static const char* const _xsd_XsdPdeTimeScheme_literals_[3];
  static const value _xsd_XsdPdeTimeScheme_indexes_[3];
};

class XsdGaussKronrodRule: public ::xml_schema::string
{
  public:
  enum value
  {
    GK15,
    GK21,
    GK31,
    GK41,
    GK51,
    GK61
  };

  XsdGaussKronrodRule ();

  XsdGaussKronrodRule (value v);

  XsdGaussKronrodRule (const char* v);

  XsdGaussKronrodRule (const ::std::string& v);

  XsdGaussKronrodRule (const ::xml_schema::string& v);

  XsdGaussKronrodRule (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdGaussKronrodRule (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdGaussKronrodRule (const ::std::string& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdGaussKronrodRule (const XsdGaussKronrodRule& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual XsdGaussKronrodRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdGaussKronrodRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdGaussKronrodRule_convert ();
  }

  protected:
  value
  _xsd_XsdGaussKronrodRule_convert () const;

  public:
  static const char* const _xsd_XsdGaussKronrodRule_literals_[6];
  static const value _xsd_XsdGaussKronrodRule_indexes_[6];
};

class XsdMinLinearBasis: public ::xml_schema::string
{
  public:
  enum value
  {
    ADVANCED,
    BIXBY,
    STANDARD
  };

  XsdMinLinearBasis ();

  XsdMinLinearBasis (value v);

  XsdMinLinearBasis (const char* v);

  XsdMinLinearBasis (const ::std::string& v);

  XsdMinLinearBasis (const ::xml_schema::string& v);

  XsdMinLinearBasis (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearBasis (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearBasis (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearBasis (const XsdMinLinearBasis& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdMinLinearBasis*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMinLinearBasis&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMinLinearBasis_convert ();
  }

  protected:
  value
  _xsd_XsdMinLinearBasis_convert () const;

  public:
  static const char* const _xsd_XsdMinLinearBasis_literals_[3];
  static const value _xsd_XsdMinLinearBasis_indexes_[3];
};

class XsdMinLinearMethod: public ::xml_schema::string
{
  public:
  enum value
  {
    INTERIOR,
    SIMPLEX
  };

  XsdMinLinearMethod ();

  XsdMinLinearMethod (value v);

  XsdMinLinearMethod (const char* v);

  XsdMinLinearMethod (const ::std::string& v);

  XsdMinLinearMethod (const ::xml_schema::string& v);

  XsdMinLinearMethod (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdMinLinearMethod (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdMinLinearMethod (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdMinLinearMethod (const XsdMinLinearMethod& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdMinLinearMethod*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMinLinearMethod&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMinLinearMethod_convert ();
  }

  protected:
  value
  _xsd_XsdMinLinearMethod_convert () const;

  public:
  static const char* const _xsd_XsdMinLinearMethod_literals_[2];
  static const value _xsd_XsdMinLinearMethod_indexes_[2];
};

class XsdMinLinearScale: public ::xml_schema::string
{
  public:
  enum value
  {
    AUTOMATIC,
    EQUILIBRATION,
    GEOMETRIC_MEAN,
    NONE
  };

  XsdMinLinearScale ();

  XsdMinLinearScale (value v);

  XsdMinLinearScale (const char* v);

  XsdMinLinearScale (const ::std::string& v);

  XsdMinLinearScale (const ::xml_schema::string& v);

  XsdMinLinearScale (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearScale (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearScale (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMinLinearScale (const XsdMinLinearScale& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdMinLinearScale*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMinLinearScale&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMinLinearScale_convert ();
  }

  protected:
  value
  _xsd_XsdMinLinearScale_convert () const;

  public:
  static const char* const _xsd_XsdMinLinearScale_literals_[4];
  static const value _xsd_XsdMinLinearScale_indexes_[4];
};

class XsdMonteCarloRule: public ::xml_schema::string
{
  public:
  enum value
  {
    PLAIN,
    MISER,
    VEGAS
  };

  XsdMonteCarloRule ();

  XsdMonteCarloRule (value v);

  XsdMonteCarloRule (const char* v);

  XsdMonteCarloRule (const ::std::string& v);

  XsdMonteCarloRule (const ::xml_schema::string& v);

  XsdMonteCarloRule (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMonteCarloRule (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMonteCarloRule (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  XsdMonteCarloRule (const XsdMonteCarloRule& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual XsdMonteCarloRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMonteCarloRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMonteCarloRule_convert ();
  }

  protected:
  value
  _xsd_XsdMonteCarloRule_convert () const;

  public:
  static const char* const _xsd_XsdMonteCarloRule_literals_[3];
  static const value _xsd_XsdMonteCarloRule_indexes_[3];
};

class XsdMultiRootType: public ::xml_schema::string
{
  public:
  enum value
  {
    BROYDEN,
    HYBRID,
    NEWTON
  };

  XsdMultiRootType ();

  XsdMultiRootType (value v);

  XsdMultiRootType (const char* v);

  XsdMultiRootType (const ::std::string& v);

  XsdMultiRootType (const ::xml_schema::string& v);

  XsdMultiRootType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdMultiRootType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdMultiRootType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdMultiRootType (const XsdMultiRootType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdMultiRootType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdMultiRootType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdMultiRootType_convert ();
  }

  protected:
  value
  _xsd_XsdMultiRootType_convert () const;

  public:
  static const char* const _xsd_XsdMultiRootType_literals_[3];
  static const value _xsd_XsdMultiRootType_indexes_[3];
};

class XsdNormalRngType: public ::xml_schema::string
{
  public:
  enum value
  {
    BOX_MULLER,
    DEFAULT,
    RATIO,
    ZIGGURAT
  };

  XsdNormalRngType ();

  XsdNormalRngType (value v);

  XsdNormalRngType (const char* v);

  XsdNormalRngType (const ::std::string& v);

  XsdNormalRngType (const ::xml_schema::string& v);

  XsdNormalRngType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdNormalRngType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdNormalRngType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdNormalRngType (const XsdNormalRngType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdNormalRngType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdNormalRngType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdNormalRngType_convert ();
  }

  protected:
  value
  _xsd_XsdNormalRngType_convert () const;

  public:
  static const char* const _xsd_XsdNormalRngType_literals_[4];
  static const value _xsd_XsdNormalRngType_indexes_[4];
};

class XsdOdeSolverType: public ::xml_schema::string
{
  public:
  enum value
  {
    BSIMP,
    GEAR1,
    GEAR2,
    RK2,
    RK2IMP,
    RK2SIMP,
    RK4,
    RK4IMP,
    RK8PD,
    RKCK,
    RKF45
  };

  XsdOdeSolverType ();

  XsdOdeSolverType (value v);

  XsdOdeSolverType (const char* v);

  XsdOdeSolverType (const ::std::string& v);

  XsdOdeSolverType (const ::xml_schema::string& v);

  XsdOdeSolverType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdOdeSolverType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdOdeSolverType (const ::std::string& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  XsdOdeSolverType (const XsdOdeSolverType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual XsdOdeSolverType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdOdeSolverType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdOdeSolverType_convert ();
  }

  protected:
  value
  _xsd_XsdOdeSolverType_convert () const;

  public:
  static const char* const _xsd_XsdOdeSolverType_literals_[11];
  static const value _xsd_XsdOdeSolverType_indexes_[11];
};

class XsdPathScheme: public ::xml_schema::string
{
  public:
  enum value
  {
    EULER,
    MILSTEIN
  };

  XsdPathScheme ();

  XsdPathScheme (value v);

  XsdPathScheme (const char* v);

  XsdPathScheme (const ::std::string& v);

  XsdPathScheme (const ::xml_schema::string& v);

  XsdPathScheme (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdPathScheme (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdPathScheme (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdPathScheme (const XsdPathScheme& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdPathScheme*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdPathScheme&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdPathScheme_convert ();
  }

  protected:
  value
  _xsd_XsdPathScheme_convert () const;

  public:
  static const char* const _xsd_XsdPathScheme_literals_[2];
  static const value _xsd_XsdPathScheme_indexes_[2];
};

class XsdRandomType: public ::xml_schema::string
{
  public:
  enum value
  {
    PSEUDO,
    QUASI
  };

  XsdRandomType ();

  XsdRandomType (value v);

  XsdRandomType (const char* v);

  XsdRandomType (const ::std::string& v);

  XsdRandomType (const ::xml_schema::string& v);

  XsdRandomType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdRandomType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdRandomType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdRandomType (const XsdRandomType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdRandomType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdRandomType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdRandomType_convert ();
  }

  protected:
  value
  _xsd_XsdRandomType_convert () const;

  public:
  static const char* const _xsd_XsdRandomType_literals_[2];
  static const value _xsd_XsdRandomType_indexes_[2];
};

class XsdSalvageType: public ::xml_schema::string
{
  public:
  enum value
  {
    NONE,
    SPECTRAL,
    HYPERSPHERE,
    LOWER_DIAGONAL,
    HIGHAM
  };

  XsdSalvageType ();

  XsdSalvageType (value v);

  XsdSalvageType (const char* v);

  XsdSalvageType (const ::std::string& v);

  XsdSalvageType (const ::xml_schema::string& v);

  XsdSalvageType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdSalvageType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdSalvageType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdSalvageType (const XsdSalvageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdSalvageType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdSalvageType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdSalvageType_convert ();
  }

  protected:
  value
  _xsd_XsdSalvageType_convert () const;

  public:
  static const char* const _xsd_XsdSalvageType_literals_[5];
  static const value _xsd_XsdSalvageType_indexes_[5];
};

class XsdRoundType: public ::xml_schema::string
{
  public:
  enum value
  {
    DOWN,
    NEAREST,
    UP
  };

  XsdRoundType ();

  XsdRoundType (value v);

  XsdRoundType (const char* v);

  XsdRoundType (const ::std::string& v);

  XsdRoundType (const ::xml_schema::string& v);

  XsdRoundType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdRoundType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdRoundType (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  XsdRoundType (const XsdRoundType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual XsdRoundType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdRoundType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdRoundType_convert ();
  }

  protected:
  value
  _xsd_XsdRoundType_convert () const;

  public:
  static const char* const _xsd_XsdRoundType_literals_[3];
  static const value _xsd_XsdRoundType_indexes_[3];
};

class XsdSingularValueType: public ::xml_schema::string
{
  public:
  enum value
  {
    DEFAULT,
    JACOBI,
    MODIFIED
  };

  XsdSingularValueType ();

  XsdSingularValueType (value v);

  XsdSingularValueType (const char* v);

  XsdSingularValueType (const ::std::string& v);

  XsdSingularValueType (const ::xml_schema::string& v);

  XsdSingularValueType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSingularValueType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSingularValueType (const ::std::string& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  XsdSingularValueType (const XsdSingularValueType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual XsdSingularValueType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdSingularValueType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdSingularValueType_convert ();
  }

  protected:
  value
  _xsd_XsdSingularValueType_convert () const;

  public:
  static const char* const _xsd_XsdSingularValueType_literals_[3];
  static const value _xsd_XsdSingularValueType_indexes_[3];
};

class XsdSobolDirectionIntegers: public ::xml_schema::string
{
  public:
  enum value
  {
    JAECKEL,
    JOE_KUO_D5,
    JOE_KUO_D6,
    JOE_KUO_D7,
    KUO,
    KUO2,
    KUO3,
    SOBOL_LEVITAN,
    SOBOL_LEVITAN_LEMIEUX,
    UNIT
  };

  XsdSobolDirectionIntegers ();

  XsdSobolDirectionIntegers (value v);

  XsdSobolDirectionIntegers (const char* v);

  XsdSobolDirectionIntegers (const ::std::string& v);

  XsdSobolDirectionIntegers (const ::xml_schema::string& v);

  XsdSobolDirectionIntegers (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdSobolDirectionIntegers (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdSobolDirectionIntegers (const ::std::string& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  XsdSobolDirectionIntegers (const XsdSobolDirectionIntegers& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual XsdSobolDirectionIntegers*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdSobolDirectionIntegers&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdSobolDirectionIntegers_convert ();
  }

  protected:
  value
  _xsd_XsdSobolDirectionIntegers_convert () const;

  public:
  static const char* const _xsd_XsdSobolDirectionIntegers_literals_[10];
  static const value _xsd_XsdSobolDirectionIntegers_indexes_[10];
};

class XsdSolverType: public ::xml_schema::string
{
  public:
  enum value
  {
    ANALYTIC,
    BINOMIAL,
    INTEGRAL,
    NONE,
    PATH,
    PDE
  };

  XsdSolverType ();

  XsdSolverType (value v);

  XsdSolverType (const char* v);

  XsdSolverType (const ::std::string& v);

  XsdSolverType (const ::xml_schema::string& v);

  XsdSolverType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSolverType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSolverType (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  XsdSolverType (const XsdSolverType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual XsdSolverType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdSolverType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdSolverType_convert ();
  }

  protected:
  value
  _xsd_XsdSolverType_convert () const;

  public:
  static const char* const _xsd_XsdSolverType_literals_[6];
  static const value _xsd_XsdSolverType_indexes_[6];
};

class XsdValueRoot1DType: public ::xml_schema::string
{
  public:
  enum value
  {
    BISECTION,
    BRENT,
    FALSE_POSITION,
    RIDDER
  };

  XsdValueRoot1DType ();

  XsdValueRoot1DType (value v);

  XsdValueRoot1DType (const char* v);

  XsdValueRoot1DType (const ::std::string& v);

  XsdValueRoot1DType (const ::xml_schema::string& v);

  XsdValueRoot1DType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdValueRoot1DType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdValueRoot1DType (const ::std::string& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  XsdValueRoot1DType (const XsdValueRoot1DType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual XsdValueRoot1DType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdValueRoot1DType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdValueRoot1DType_convert ();
  }

  protected:
  value
  _xsd_XsdValueRoot1DType_convert () const;

  public:
  static const char* const _xsd_XsdValueRoot1DType_literals_[4];
  static const value _xsd_XsdValueRoot1DType_indexes_[4];
};

class XsdWaveletType: public ::xml_schema::string
{
  public:
  enum value
  {
    BSPLINE,
    DAUBECHIES,
    HAAR
  };

  XsdWaveletType ();

  XsdWaveletType (value v);

  XsdWaveletType (const char* v);

  XsdWaveletType (const ::std::string& v);

  XsdWaveletType (const ::xml_schema::string& v);

  XsdWaveletType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdWaveletType (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdWaveletType (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdWaveletType (const XsdWaveletType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdWaveletType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  XsdWaveletType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_XsdWaveletType_convert ();
  }

  protected:
  value
  _xsd_XsdWaveletType_convert () const;

  public:
  static const char* const _xsd_XsdWaveletType_literals_[3];
  static const value _xsd_XsdWaveletType_indexes_[3];
};

#ifndef XSD_DONT_INCLUDE_INLINE

#include "../xsd-core/enums.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, XsdAggregateType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdAggregateType&);

::std::ostream&
operator<< (::std::ostream&, XsdAmericanAnalyticType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdAmericanAnalyticType&);

::std::ostream&
operator<< (::std::ostream&, XsdAverageType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdAverageType&);

::std::ostream&
operator<< (::std::ostream&, XsdBinomialType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdBinomialType&);

::std::ostream&
operator<< (::std::ostream&, XsdConjugateGradientType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdConjugateGradientType&);

::std::ostream&
operator<< (::std::ostream&, XsdCopulaType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdCopulaType&);

::std::ostream&
operator<< (::std::ostream&, XsdCorrelationType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdCorrelationType&);

::std::ostream&
operator<< (::std::ostream&, XsdCubicBoundaryType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdCubicBoundaryType&);

::std::ostream&
operator<< (::std::ostream&, XsdCubicDerivativeType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdCubicDerivativeType&);

::std::ostream&
operator<< (::std::ostream&, XsdDifferenceType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdDifferenceType&);

::std::ostream&
operator<< (::std::ostream&, XsdDistributionType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdDistributionType&);

::std::ostream&
operator<< (::std::ostream&, XsdEndpointType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdEndpointType&);

::std::ostream&
operator<< (::std::ostream&, XsdErrorType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdErrorType&);

::std::ostream&
operator<< (::std::ostream&, XsdEvolveType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdEvolveType&);

::std::ostream&
operator<< (::std::ostream&, XsdExtrapolate::value);

::std::ostream&
operator<< (::std::ostream&, const XsdExtrapolate&);

::std::ostream&
operator<< (::std::ostream&, XsdFdmScheme::value);

::std::ostream&
operator<< (::std::ostream&, const XsdFdmScheme&);

::std::ostream&
operator<< (::std::ostream&, XsdGammaRngType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdGammaRngType&);

::std::ostream&
operator<< (::std::ostream&, XsdGradientRoot1DType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdGradientRoot1DType&);

::std::ostream&
operator<< (::std::ostream&, XsdMomentType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMomentType&);

::std::ostream&
operator<< (::std::ostream&, XsdPdeTimeScheme::value);

::std::ostream&
operator<< (::std::ostream&, const XsdPdeTimeScheme&);

::std::ostream&
operator<< (::std::ostream&, XsdGaussKronrodRule::value);

::std::ostream&
operator<< (::std::ostream&, const XsdGaussKronrodRule&);

::std::ostream&
operator<< (::std::ostream&, XsdMinLinearBasis::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMinLinearBasis&);

::std::ostream&
operator<< (::std::ostream&, XsdMinLinearMethod::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMinLinearMethod&);

::std::ostream&
operator<< (::std::ostream&, XsdMinLinearScale::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMinLinearScale&);

::std::ostream&
operator<< (::std::ostream&, XsdMonteCarloRule::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMonteCarloRule&);

::std::ostream&
operator<< (::std::ostream&, XsdMultiRootType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdMultiRootType&);

::std::ostream&
operator<< (::std::ostream&, XsdNormalRngType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdNormalRngType&);

::std::ostream&
operator<< (::std::ostream&, XsdOdeSolverType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdOdeSolverType&);

::std::ostream&
operator<< (::std::ostream&, XsdPathScheme::value);

::std::ostream&
operator<< (::std::ostream&, const XsdPathScheme&);

::std::ostream&
operator<< (::std::ostream&, XsdRandomType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdRandomType&);

::std::ostream&
operator<< (::std::ostream&, XsdSalvageType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdSalvageType&);

::std::ostream&
operator<< (::std::ostream&, XsdRoundType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdRoundType&);

::std::ostream&
operator<< (::std::ostream&, XsdSingularValueType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdSingularValueType&);

::std::ostream&
operator<< (::std::ostream&, XsdSobolDirectionIntegers::value);

::std::ostream&
operator<< (::std::ostream&, const XsdSobolDirectionIntegers&);

::std::ostream&
operator<< (::std::ostream&, XsdSolverType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdSolverType&);

::std::ostream&
operator<< (::std::ostream&, XsdValueRoot1DType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdValueRoot1DType&);

::std::ostream&
operator<< (::std::ostream&, XsdWaveletType::value);

::std::ostream&
operator<< (::std::ostream&, const XsdWaveletType&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdAggregateType&);

void
operator<< (xercesc::DOMAttr&, const XsdAggregateType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdAggregateType&);

void
operator<< (xercesc::DOMElement&, const XsdAmericanAnalyticType&);

void
operator<< (xercesc::DOMAttr&, const XsdAmericanAnalyticType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdAmericanAnalyticType&);

void
operator<< (xercesc::DOMElement&, const XsdAverageType&);

void
operator<< (xercesc::DOMAttr&, const XsdAverageType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdAverageType&);

void
operator<< (xercesc::DOMElement&, const XsdBinomialType&);

void
operator<< (xercesc::DOMAttr&, const XsdBinomialType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdBinomialType&);

void
operator<< (xercesc::DOMElement&, const XsdConjugateGradientType&);

void
operator<< (xercesc::DOMAttr&, const XsdConjugateGradientType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdConjugateGradientType&);

void
operator<< (xercesc::DOMElement&, const XsdCopulaType&);

void
operator<< (xercesc::DOMAttr&, const XsdCopulaType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdCopulaType&);

void
operator<< (xercesc::DOMElement&, const XsdCorrelationType&);

void
operator<< (xercesc::DOMAttr&, const XsdCorrelationType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdCorrelationType&);

void
operator<< (xercesc::DOMElement&, const XsdCubicBoundaryType&);

void
operator<< (xercesc::DOMAttr&, const XsdCubicBoundaryType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdCubicBoundaryType&);

void
operator<< (xercesc::DOMElement&, const XsdCubicDerivativeType&);

void
operator<< (xercesc::DOMAttr&, const XsdCubicDerivativeType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdCubicDerivativeType&);

void
operator<< (xercesc::DOMElement&, const XsdDifferenceType&);

void
operator<< (xercesc::DOMAttr&, const XsdDifferenceType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdDifferenceType&);

void
operator<< (xercesc::DOMElement&, const XsdDistributionType&);

void
operator<< (xercesc::DOMAttr&, const XsdDistributionType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdDistributionType&);

void
operator<< (xercesc::DOMElement&, const XsdEndpointType&);

void
operator<< (xercesc::DOMAttr&, const XsdEndpointType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdEndpointType&);

void
operator<< (xercesc::DOMElement&, const XsdErrorType&);

void
operator<< (xercesc::DOMAttr&, const XsdErrorType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdErrorType&);

void
operator<< (xercesc::DOMElement&, const XsdEvolveType&);

void
operator<< (xercesc::DOMAttr&, const XsdEvolveType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdEvolveType&);

void
operator<< (xercesc::DOMElement&, const XsdExtrapolate&);

void
operator<< (xercesc::DOMAttr&, const XsdExtrapolate&);

void
operator<< (::xml_schema::list_stream&,
            const XsdExtrapolate&);

void
operator<< (xercesc::DOMElement&, const XsdFdmScheme&);

void
operator<< (xercesc::DOMAttr&, const XsdFdmScheme&);

void
operator<< (::xml_schema::list_stream&,
            const XsdFdmScheme&);

void
operator<< (xercesc::DOMElement&, const XsdGammaRngType&);

void
operator<< (xercesc::DOMAttr&, const XsdGammaRngType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdGammaRngType&);

void
operator<< (xercesc::DOMElement&, const XsdGradientRoot1DType&);

void
operator<< (xercesc::DOMAttr&, const XsdGradientRoot1DType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdGradientRoot1DType&);

void
operator<< (xercesc::DOMElement&, const XsdMomentType&);

void
operator<< (xercesc::DOMAttr&, const XsdMomentType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMomentType&);

void
operator<< (xercesc::DOMElement&, const XsdPdeTimeScheme&);

void
operator<< (xercesc::DOMAttr&, const XsdPdeTimeScheme&);

void
operator<< (::xml_schema::list_stream&,
            const XsdPdeTimeScheme&);

void
operator<< (xercesc::DOMElement&, const XsdGaussKronrodRule&);

void
operator<< (xercesc::DOMAttr&, const XsdGaussKronrodRule&);

void
operator<< (::xml_schema::list_stream&,
            const XsdGaussKronrodRule&);

void
operator<< (xercesc::DOMElement&, const XsdMinLinearBasis&);

void
operator<< (xercesc::DOMAttr&, const XsdMinLinearBasis&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMinLinearBasis&);

void
operator<< (xercesc::DOMElement&, const XsdMinLinearMethod&);

void
operator<< (xercesc::DOMAttr&, const XsdMinLinearMethod&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMinLinearMethod&);

void
operator<< (xercesc::DOMElement&, const XsdMinLinearScale&);

void
operator<< (xercesc::DOMAttr&, const XsdMinLinearScale&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMinLinearScale&);

void
operator<< (xercesc::DOMElement&, const XsdMonteCarloRule&);

void
operator<< (xercesc::DOMAttr&, const XsdMonteCarloRule&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMonteCarloRule&);

void
operator<< (xercesc::DOMElement&, const XsdMultiRootType&);

void
operator<< (xercesc::DOMAttr&, const XsdMultiRootType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdMultiRootType&);

void
operator<< (xercesc::DOMElement&, const XsdNormalRngType&);

void
operator<< (xercesc::DOMAttr&, const XsdNormalRngType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdNormalRngType&);

void
operator<< (xercesc::DOMElement&, const XsdOdeSolverType&);

void
operator<< (xercesc::DOMAttr&, const XsdOdeSolverType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdOdeSolverType&);

void
operator<< (xercesc::DOMElement&, const XsdPathScheme&);

void
operator<< (xercesc::DOMAttr&, const XsdPathScheme&);

void
operator<< (::xml_schema::list_stream&,
            const XsdPathScheme&);

void
operator<< (xercesc::DOMElement&, const XsdRandomType&);

void
operator<< (xercesc::DOMAttr&, const XsdRandomType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdRandomType&);

void
operator<< (xercesc::DOMElement&, const XsdSalvageType&);

void
operator<< (xercesc::DOMAttr&, const XsdSalvageType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSalvageType&);

void
operator<< (xercesc::DOMElement&, const XsdRoundType&);

void
operator<< (xercesc::DOMAttr&, const XsdRoundType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdRoundType&);

void
operator<< (xercesc::DOMElement&, const XsdSingularValueType&);

void
operator<< (xercesc::DOMAttr&, const XsdSingularValueType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSingularValueType&);

void
operator<< (xercesc::DOMElement&, const XsdSobolDirectionIntegers&);

void
operator<< (xercesc::DOMAttr&, const XsdSobolDirectionIntegers&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSobolDirectionIntegers&);

void
operator<< (xercesc::DOMElement&, const XsdSolverType&);

void
operator<< (xercesc::DOMAttr&, const XsdSolverType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdSolverType&);

void
operator<< (xercesc::DOMElement&, const XsdValueRoot1DType&);

void
operator<< (xercesc::DOMAttr&, const XsdValueRoot1DType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdValueRoot1DType&);

void
operator<< (xercesc::DOMElement&, const XsdWaveletType&);

void
operator<< (xercesc::DOMAttr&, const XsdWaveletType&);

void
operator<< (::xml_schema::list_stream&,
            const XsdWaveletType&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "enums.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_ENUMS_HXX
