// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_CONSTRAINT_HXX
#define CXX___SCHEMA_XSD_MATH_CONSTRAINT_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "../xsd-base/xml-schema.hxx"

// Forward declarations.
//
class XsdConstraints;
class XsdLinearConstraint;
class XsdLinearConstraintPair;
class XsdNonLinearConstraint;
class XsdNonLinearConstraintPair;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#include "functional.hxx"

#undef XSD_DONT_INCLUDE_INLINE
#else

#include "functional.hxx"

#endif // XSD_DONT_INCLUDE_INLINE

class XsdConstraints: public ::xml_schema::type
{
  public:
  // bound
  // 
  typedef ::XsdDoubleBounds bound_type;
  typedef ::xsd::cxx::tree::sequence< bound_type > bound_sequence;
  typedef xsd::cxx::tree::sequence< bound_type >::iterator bound_iterator;
  typedef xsd::cxx::tree::sequence< bound_type >::const_iterator bound_const_iterator;
  typedef ::xsd::cxx::tree::traits< bound_type, char > bound_traits;

  const bound_sequence&
  bound () const;

  bound_sequence&
  bound ();

  void
  bound (const bound_sequence& s);

  // linear
  // 
  typedef ::XsdLinearConstraintPair linear_type;
  typedef ::xsd::cxx::tree::optional< linear_type > linear_optional;
  typedef ::xsd::cxx::tree::traits< linear_type, char > linear_traits;

  const linear_optional&
  linear () const;

  linear_optional&
  linear ();

  void
  linear (const linear_type& x);

  void
  linear (const linear_optional& x);

  void
  linear (::std::auto_ptr< linear_type > p);

  // nonlinear
  // 
  typedef ::XsdNonLinearConstraintPair nonlinear_type;
  typedef ::xsd::cxx::tree::optional< nonlinear_type > nonlinear_optional;
  typedef ::xsd::cxx::tree::traits< nonlinear_type, char > nonlinear_traits;

  const nonlinear_optional&
  nonlinear () const;

  nonlinear_optional&
  nonlinear ();

  void
  nonlinear (const nonlinear_type& x);

  void
  nonlinear (const nonlinear_optional& x);

  void
  nonlinear (::std::auto_ptr< nonlinear_type > p);

  // Constructors.
  //
  XsdConstraints ();

  XsdConstraints (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  XsdConstraints (const XsdConstraints& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual XsdConstraints*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdConstraints ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  bound_sequence bound_;
  linear_optional linear_;
  nonlinear_optional nonlinear_;
};

bool
operator== (const XsdConstraints&, const XsdConstraints&);

bool
operator!= (const XsdConstraints&, const XsdConstraints&);


class XsdLinearConstraint: public ::XsdDoubleVector
{
  public:
  // value
  // 
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  static value_type
  value_default_value ();

  // tolerance
  // 
  typedef ::xml_schema::double_ tolerance_type;
  typedef ::xsd::cxx::tree::traits< tolerance_type, char, ::xsd::cxx::tree::schema_type::double_ > tolerance_traits;

  const tolerance_type&
  tolerance () const;

  tolerance_type&
  tolerance ();

  void
  tolerance (const tolerance_type& x);

  static tolerance_type
  tolerance_default_value ();

  // Constructors.
  //
  XsdLinearConstraint ();

  XsdLinearConstraint (const ::XsdDoubleVector&);

  XsdLinearConstraint (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  XsdLinearConstraint (const XsdLinearConstraint& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual XsdLinearConstraint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdLinearConstraint ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< tolerance_type > tolerance_;
};

bool
operator== (const XsdLinearConstraint&, const XsdLinearConstraint&);

bool
operator!= (const XsdLinearConstraint&, const XsdLinearConstraint&);


class XsdLinearConstraintPair: public ::xml_schema::type
{
  public:
  // equality
  // 
  typedef ::XsdLinearConstraint equality_type;
  typedef ::xsd::cxx::tree::sequence< equality_type > equality_sequence;
  typedef xsd::cxx::tree::sequence< equality_type >::iterator equality_iterator;
  typedef xsd::cxx::tree::sequence< equality_type >::const_iterator equality_const_iterator;
  typedef ::xsd::cxx::tree::traits< equality_type, char > equality_traits;

  const equality_sequence&
  equality () const;

  equality_sequence&
  equality ();

  void
  equality (const equality_sequence& s);

  // inequality
  // 
  typedef ::XsdLinearConstraint inequality_type;
  typedef ::xsd::cxx::tree::sequence< inequality_type > inequality_sequence;
  typedef xsd::cxx::tree::sequence< inequality_type >::iterator inequality_iterator;
  typedef xsd::cxx::tree::sequence< inequality_type >::const_iterator inequality_const_iterator;
  typedef ::xsd::cxx::tree::traits< inequality_type, char > inequality_traits;

  const inequality_sequence&
  inequality () const;

  inequality_sequence&
  inequality ();

  void
  inequality (const inequality_sequence& s);

  // Constructors.
  //
  XsdLinearConstraintPair ();

  XsdLinearConstraintPair (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  XsdLinearConstraintPair (const XsdLinearConstraintPair& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual XsdLinearConstraintPair*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdLinearConstraintPair ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  equality_sequence equality_;
  inequality_sequence inequality_;
};

bool
operator== (const XsdLinearConstraintPair&, const XsdLinearConstraintPair&);

bool
operator!= (const XsdLinearConstraintPair&, const XsdLinearConstraintPair&);


class XsdNonLinearConstraint: public ::xml_schema::type
{
  public:
  // function
  // 
  typedef ::XsdFunction function_type;
  typedef ::xsd::cxx::tree::traits< function_type, char > function_traits;

  const function_type&
  function () const;

  function_type&
  function ();

  void
  function (const function_type& x);

  void
  function (::std::auto_ptr< function_type > p);

  // value
  // 
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  static value_type
  value_default_value ();

  // tolerance
  // 
  typedef ::xml_schema::double_ tolerance_type;
  typedef ::xsd::cxx::tree::traits< tolerance_type, char, ::xsd::cxx::tree::schema_type::double_ > tolerance_traits;

  const tolerance_type&
  tolerance () const;

  tolerance_type&
  tolerance ();

  void
  tolerance (const tolerance_type& x);

  static tolerance_type
  tolerance_default_value ();

  // gradient
  // 
  typedef ::xml_schema::boolean gradient_type;
  typedef ::xsd::cxx::tree::traits< gradient_type, char > gradient_traits;

  const gradient_type&
  gradient () const;

  gradient_type&
  gradient ();

  void
  gradient (const gradient_type& x);

  static gradient_type
  gradient_default_value ();

  // Constructors.
  //
  XsdNonLinearConstraint ();

  XsdNonLinearConstraint (const function_type&);

  XsdNonLinearConstraint (::std::auto_ptr< function_type >&);

  XsdNonLinearConstraint (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  XsdNonLinearConstraint (const XsdNonLinearConstraint& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual XsdNonLinearConstraint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdNonLinearConstraint ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< function_type > function_;
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< tolerance_type > tolerance_;
  ::xsd::cxx::tree::one< gradient_type > gradient_;
};

bool
operator== (const XsdNonLinearConstraint&, const XsdNonLinearConstraint&);

bool
operator!= (const XsdNonLinearConstraint&, const XsdNonLinearConstraint&);


class XsdNonLinearConstraintPair: public ::xml_schema::type
{
  public:
  // equality
  // 
  typedef ::XsdNonLinearConstraint equality_type;
  typedef ::xsd::cxx::tree::sequence< equality_type > equality_sequence;
  typedef xsd::cxx::tree::sequence< equality_type >::iterator equality_iterator;
  typedef xsd::cxx::tree::sequence< equality_type >::const_iterator equality_const_iterator;
  typedef ::xsd::cxx::tree::traits< equality_type, char > equality_traits;

  const equality_sequence&
  equality () const;

  equality_sequence&
  equality ();

  void
  equality (const equality_sequence& s);

  // inequality
  // 
  typedef ::XsdNonLinearConstraint inequality_type;
  typedef ::xsd::cxx::tree::sequence< inequality_type > inequality_sequence;
  typedef xsd::cxx::tree::sequence< inequality_type >::iterator inequality_iterator;
  typedef xsd::cxx::tree::sequence< inequality_type >::const_iterator inequality_const_iterator;
  typedef ::xsd::cxx::tree::traits< inequality_type, char > inequality_traits;

  const inequality_sequence&
  inequality () const;

  inequality_sequence&
  inequality ();

  void
  inequality (const inequality_sequence& s);

  // Constructors.
  //
  XsdNonLinearConstraintPair ();

  XsdNonLinearConstraintPair (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  XsdNonLinearConstraintPair (const XsdNonLinearConstraintPair& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual XsdNonLinearConstraintPair*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~XsdNonLinearConstraintPair ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  equality_sequence equality_;
  inequality_sequence inequality_;
};

bool
operator== (const XsdNonLinearConstraintPair&, const XsdNonLinearConstraintPair&);

bool
operator!= (const XsdNonLinearConstraintPair&, const XsdNonLinearConstraintPair&);


#ifndef XSD_DONT_INCLUDE_INLINE

#include "functional.ixx"

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const XsdConstraints&);

::std::ostream&
operator<< (::std::ostream&, const XsdLinearConstraint&);

::std::ostream&
operator<< (::std::ostream&, const XsdLinearConstraintPair&);

::std::ostream&
operator<< (::std::ostream&, const XsdNonLinearConstraint&);

::std::ostream&
operator<< (::std::ostream&, const XsdNonLinearConstraintPair&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (xercesc::DOMElement&, const XsdConstraints&);

void
operator<< (xercesc::DOMElement&, const XsdLinearConstraint&);

void
operator<< (xercesc::DOMElement&, const XsdLinearConstraintPair&);

void
operator<< (xercesc::DOMElement&, const XsdNonLinearConstraint&);

void
operator<< (xercesc::DOMElement&, const XsdNonLinearConstraintPair&);

#ifndef XSD_DONT_INCLUDE_INLINE
#include "constraint.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_CONSTRAINT_HXX
