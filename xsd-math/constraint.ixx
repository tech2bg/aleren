// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMA_XSD_MATH_CONSTRAINT_IXX
#define CXX___SCHEMA_XSD_MATH_CONSTRAINT_IXX

// Begin prologue.
//
//
// End prologue.

#include "functional.ixx"

// XsdConstraints
// 

inline
const XsdConstraints::bound_sequence& XsdConstraints::
bound () const
{
  return this->bound_;
}

inline
XsdConstraints::bound_sequence& XsdConstraints::
bound ()
{
  return this->bound_;
}

inline
void XsdConstraints::
bound (const bound_sequence& s)
{
  this->bound_ = s;
}

inline
const XsdConstraints::linear_optional& XsdConstraints::
linear () const
{
  return this->linear_;
}

inline
XsdConstraints::linear_optional& XsdConstraints::
linear ()
{
  return this->linear_;
}

inline
void XsdConstraints::
linear (const linear_type& x)
{
  this->linear_.set (x);
}

inline
void XsdConstraints::
linear (const linear_optional& x)
{
  this->linear_ = x;
}

inline
void XsdConstraints::
linear (::std::auto_ptr< linear_type > x)
{
  this->linear_.set (x);
}

inline
const XsdConstraints::nonlinear_optional& XsdConstraints::
nonlinear () const
{
  return this->nonlinear_;
}

inline
XsdConstraints::nonlinear_optional& XsdConstraints::
nonlinear ()
{
  return this->nonlinear_;
}

inline
void XsdConstraints::
nonlinear (const nonlinear_type& x)
{
  this->nonlinear_.set (x);
}

inline
void XsdConstraints::
nonlinear (const nonlinear_optional& x)
{
  this->nonlinear_ = x;
}

inline
void XsdConstraints::
nonlinear (::std::auto_ptr< nonlinear_type > x)
{
  this->nonlinear_.set (x);
}


// XsdLinearConstraint
// 

inline
const XsdLinearConstraint::value_type& XsdLinearConstraint::
value () const
{
  return this->value_.get ();
}

inline
XsdLinearConstraint::value_type& XsdLinearConstraint::
value ()
{
  return this->value_.get ();
}

inline
void XsdLinearConstraint::
value (const value_type& x)
{
  this->value_.set (x);
}

inline
XsdLinearConstraint::value_type XsdLinearConstraint::
value_default_value ()
{
  return value_type (.0);
}

inline
const XsdLinearConstraint::tolerance_type& XsdLinearConstraint::
tolerance () const
{
  return this->tolerance_.get ();
}

inline
XsdLinearConstraint::tolerance_type& XsdLinearConstraint::
tolerance ()
{
  return this->tolerance_.get ();
}

inline
void XsdLinearConstraint::
tolerance (const tolerance_type& x)
{
  this->tolerance_.set (x);
}

inline
XsdLinearConstraint::tolerance_type XsdLinearConstraint::
tolerance_default_value ()
{
  return tolerance_type (1.0e-4);
}


// XsdLinearConstraintPair
// 

inline
const XsdLinearConstraintPair::equality_sequence& XsdLinearConstraintPair::
equality () const
{
  return this->equality_;
}

inline
XsdLinearConstraintPair::equality_sequence& XsdLinearConstraintPair::
equality ()
{
  return this->equality_;
}

inline
void XsdLinearConstraintPair::
equality (const equality_sequence& s)
{
  this->equality_ = s;
}

inline
const XsdLinearConstraintPair::inequality_sequence& XsdLinearConstraintPair::
inequality () const
{
  return this->inequality_;
}

inline
XsdLinearConstraintPair::inequality_sequence& XsdLinearConstraintPair::
inequality ()
{
  return this->inequality_;
}

inline
void XsdLinearConstraintPair::
inequality (const inequality_sequence& s)
{
  this->inequality_ = s;
}


// XsdNonLinearConstraint
// 

inline
const XsdNonLinearConstraint::function_type& XsdNonLinearConstraint::
function () const
{
  return this->function_.get ();
}

inline
XsdNonLinearConstraint::function_type& XsdNonLinearConstraint::
function ()
{
  return this->function_.get ();
}

inline
void XsdNonLinearConstraint::
function (const function_type& x)
{
  this->function_.set (x);
}

inline
void XsdNonLinearConstraint::
function (::std::auto_ptr< function_type > x)
{
  this->function_.set (x);
}

inline
const XsdNonLinearConstraint::value_type& XsdNonLinearConstraint::
value () const
{
  return this->value_.get ();
}

inline
XsdNonLinearConstraint::value_type& XsdNonLinearConstraint::
value ()
{
  return this->value_.get ();
}

inline
void XsdNonLinearConstraint::
value (const value_type& x)
{
  this->value_.set (x);
}

inline
XsdNonLinearConstraint::value_type XsdNonLinearConstraint::
value_default_value ()
{
  return value_type (.0);
}

inline
const XsdNonLinearConstraint::tolerance_type& XsdNonLinearConstraint::
tolerance () const
{
  return this->tolerance_.get ();
}

inline
XsdNonLinearConstraint::tolerance_type& XsdNonLinearConstraint::
tolerance ()
{
  return this->tolerance_.get ();
}

inline
void XsdNonLinearConstraint::
tolerance (const tolerance_type& x)
{
  this->tolerance_.set (x);
}

inline
XsdNonLinearConstraint::tolerance_type XsdNonLinearConstraint::
tolerance_default_value ()
{
  return tolerance_type (1.0e-4);
}

inline
const XsdNonLinearConstraint::gradient_type& XsdNonLinearConstraint::
gradient () const
{
  return this->gradient_.get ();
}

inline
XsdNonLinearConstraint::gradient_type& XsdNonLinearConstraint::
gradient ()
{
  return this->gradient_.get ();
}

inline
void XsdNonLinearConstraint::
gradient (const gradient_type& x)
{
  this->gradient_.set (x);
}

inline
XsdNonLinearConstraint::gradient_type XsdNonLinearConstraint::
gradient_default_value ()
{
  return gradient_type (false);
}


// XsdNonLinearConstraintPair
// 

inline
const XsdNonLinearConstraintPair::equality_sequence& XsdNonLinearConstraintPair::
equality () const
{
  return this->equality_;
}

inline
XsdNonLinearConstraintPair::equality_sequence& XsdNonLinearConstraintPair::
equality ()
{
  return this->equality_;
}

inline
void XsdNonLinearConstraintPair::
equality (const equality_sequence& s)
{
  this->equality_ = s;
}

inline
const XsdNonLinearConstraintPair::inequality_sequence& XsdNonLinearConstraintPair::
inequality () const
{
  return this->inequality_;
}

inline
XsdNonLinearConstraintPair::inequality_sequence& XsdNonLinearConstraintPair::
inequality ()
{
  return this->inequality_;
}

inline
void XsdNonLinearConstraintPair::
inequality (const inequality_sequence& s)
{
  this->inequality_ = s;
}


// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMA_XSD_MATH_CONSTRAINT_IXX
